<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20240927151701.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735805000000302e302e3771067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c75735803000000302e31710d7d710e580b0000005f5f626f6f6b6d61726b73710f7d7110580700000069735f6475706571114930300a7373752e"><vh>Startup</vh>
<v t="ekr.20240927151701.9" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3771067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>@settings</vh>
<v t="ekr.20240927151701.44"><vh>@bool allow-text-zoom = True</vh></v>
<v t="ekr.20240927151701.45"><vh>@bool check-python-code-on-write = False</vh></v>
<v t="ekr.20240927151701.46"><vh>@bool use-german-keyboard = False</vh></v>
<v t="ekr.20240927151701.47"><vh>@bool use-mouse-expand-gestures = False</vh></v>
<v t="ekr.20240927151701.48"><vh>@data exec-script-commands</vh></v>
<v t="ekr.20240927151701.49"><vh>@data exec-script-patterns</vh></v>
<v t="ekr.20240927151701.50"><vh>@data history-list</vh></v>
<v t="ekr.20240927151701.170" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
<v t="ekr.20240927151701.51"><vh>@string qt-layout-name = legacy</vh></v>
<v t="ekr.20240927151701.63"><vh>Abbreviation settings</vh>
<v t="ekr.20240927151701.64"><vh>@bool enable-abbreviations = True</vh></v>
<v t="ekr.20240927151701.65"><vh>@outline-data tree-abbreviations</vh>
<v t="ekr.20240927151701.66"><vh>@organizer 1</vh>
<v t="ekr.20240927151701.67"><vh>@organizer 2</vh>
<v t="ekr.20240927151701.68"><vh>demo;;</vh>
<v t="ekr.20240927151701.69"><vh>@@button MyDemo @key=Ctrl-9</vh>
<v t="ekr.20240927151701.70"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20240927151701.71"><vh>script_string</vh></v>
<v t="ekr.20240927151701.72"><vh>class myDemo</vh></v>
<v t="ekr.20240927151701.73"><vh>wrappers</vh></v>
</v>
</v>
</v>
<v t="ekr.20240927151701.74"><vh>per-commander-plugin;;</vh>
<v t="ekr.20240927151701.75"><vh>@@file pluginname.py</vh>
<v t="ekr.20240927151701.76"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20240927151701.77"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20240927151701.78"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20240927151701.79"><vh>init</vh></v>
<v t="ekr.20240927151701.80"><vh>onCreate</vh></v>
<v t="ekr.20240927151701.81"><vh>class pluginController</vh>
<v t="ekr.20240927151701.82"><vh>__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20240927151701.83"><vh>importer;;</vh>
<v t="ekr.20240927151701.84"><vh>@@file importers/{|{x=name}|}.py</vh>
<v t="ekr.20240927151701.85"><vh>class {|{x=cap_name}|}_Importer</vh>
<v t="ekr.20240927151701.86"><vh>{|{x=name}|}.Overrides</vh>
<v t="ekr.20240927151701.87"><vh>{|{x=name}|}.clean_headline</vh></v>
<v t="ekr.20240927151701.88"><vh>{|{x=name}|}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20240927151701.89"><vh>class class {|{x=cap_name}|}_ScanState</vh>
<v t="ekr.20240927151701.90"><vh>{|{x=name}|}_state.level</vh></v>
<v t="ekr.20240927151701.91"><vh>{|{x=name}|}_state.update</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20240927151701.92"><vh>Appearance settings</vh>
<v t="ekr.20240927151701.93"><vh>@bool log-pane-wraps = False</vh></v>
<v t="ekr.20240927151701.94"><vh>@bool recent-files-group-always = True</vh></v>
<v t="ekr.20240927151701.95"><vh>@bool show-iconbar = True</vh></v>
<v t="ekr.20240927151701.96"><vh>@bool show-tips = False</vh></v>
<v t="ekr.20240927151701.97"><vh>@bool stayInTreeAfterSelect = True</vh></v>
<v t="ekr.20240927151701.98"><vh>@bool use-chapter-tabs = False</vh></v>
<v t="ekr.20240927151701.99"><vh>@bool use-chapters = False</vh></v>
<v t="ekr.20240927151701.100"><vh>@bool use-gutter = False</vh></v>
<v t="ekr.20240927151701.101"><vh>@int qweb-view-font-size = 30</vh></v>
<v t="ekr.20240927151701.102"><vh>@string initial-split-orientation = v</vh></v>
</v>
<v t="ekr.20240927151701.103"><vh>Coloring settings</vh>
<v t="ekr.20240927151701.104"><vh>@bool color-doc-parts-as-rest = True</vh></v>
<v t="ekr.20240927151701.105"><vh>@bool use-pygments = False</vh></v>
<v t="ekr.20240927151701.106"><vh>@bool use-pygments-styles = False</vh></v>
<v t="ekr.20240927151701.107"><vh>@color head-bg = @mistyrose2</vh></v>
<v t="ekr.20240927151701.108"><vh>@string pygments-style-name = leonine</vh></v>
<v t="ekr.20240927151701.109"><vh>@string target-language = rust</vh></v>
</v>
<v t="ekr.20240927151701.110"><vh>Command settings</vh>
<v t="ekr.20240927151701.111"><vh>@bool create-at-persistence-nodes-automatically = False</vh></v>
<v t="ekr.20240927151701.112"><vh>@bool enable-persistence = False</vh></v>
<v t="ekr.20240927151701.113"><vh>@bool make-node-conflicts-node = True</vh></v>
<v t="ekr.20240927151701.184"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20240927151701.114"><vh>@bool run-pyflakes-on-write = False</vh></v>
<v t="ekr.20240927151701.126"><vh>@bool tree-declutter = False</vh></v>
<v t="ekr.20240927151701.115"><vh>@bool use-jedi = False</vh></v>
<v t="ekr.20240927151701.116"><vh>@bool use-qcompleter = False</vh></v>
<v t="ekr.20240927151701.202"><vh>@bool vim-mode = False</vh></v>
<v t="ekr.20240927151701.117"><vh>@bool warn-about-redefined-shortcuts = True</vh></v>
<v t="ekr.20240927151701.118"><vh>@int auto-justify = 80</vh></v>
<v t="ekr.20240927151701.119"><vh>rst3 path options</vh>
<v t="ekr.20240927151701.120"><vh>@string rst3-write-intermediate-extension = .txt</vh></v>
<v t="ekr.20240927151701.121"><vh>@string rst3-default-path = None</vh></v>
<v t="ekr.20240927151701.122"><vh>@string rst3-stylesheet-name = default.css</vh></v>
<v t="ekr.20240927151701.123"><vh>@string rst3-stylesheet-path = None</vh></v>
<v t="ekr.20240927151701.124"><vh>@string rst3-publish-argv-for-missing-stylesheets = None</vh></v>
</v>
</v>
<v t="ekr.20240927151701.144"><vh>File settings</vh>
<v t="ekr.20240927151701.145"><vh>@bool open-with-clean-filenames = True</vh></v>
<v t="ekr.20240927151701.146"><vh>@bool check-for-changed-external-files = True</vh></v>
<v t="ekr.20240927151701.147"><vh>@bool open-with-save-on-update = False</vh></v>
<v t="ekr.20240927151701.148"><vh>@bool open-with-uses-derived-file-extensions = True</vh></v>
</v>
<v t="ekr.20240927151701.149"><vh>Find settings</vh>
<v t="ekr.20240927151701.150"><vh>@bool auto-scroll-find-tab = False</vh></v>
<v t="ekr.20240927151701.151"><vh>@bool close-find-dialog-after-search = False</vh></v>
<v t="ekr.20240927151701.152"><vh>@bool find-ignore-duplicates = False</vh></v>
<v t="ekr.20240927151701.153"><vh>@bool minibuffer-find-mode = True</vh></v>
<v t="ekr.20240927151701.154"><vh>@bool use-find-dialog = False</vh></v>
</v>
<v t="ekr.20240927151701.155"><vh>Importer settings</vh>
<v t="ekr.20240927151701.156"><vh>@data import-html-tags</vh></v>
<v t="ekr.20240927151701.157"><vh>@data import-xml-tags</vh></v>
</v>
<v t="ekr.20240927153018.1"><vh>Scripts</vh>
<v t="ekr.20240927151701.229"><vh> Recursive import script</vh>
<v t="ekr.20240927151701.230"><vh>&lt;&lt; rust dir_list &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20240927151701.190"><vh>Syntax coloring settings</vh>
<v t="ekr.20240927151701.191"><vh>@@color rest.keyword2 = red</vh></v>
<v t="ekr.20240927151701.192"><vh>@@color rest.keyword4 = blue</vh></v>
<v t="ekr.20240927151701.193"><vh>@@color rest.leokeyword = green</vh></v>
<v t="ekr.20240927151701.194"><vh>@color forth.keyword3 = black</vh></v>
<v t="ekr.20240927151701.195"><vh>@color python.name = @solarized-yellow</vh></v>
<v t="ekr.20240927151701.196"><vh>@font rest.comment1</vh></v>
</v>
<v t="ekr.20240927151701.176"><vh>VR settings</vh>
<v t="ekr.20240927151701.177"><vh>@bool view-rendered-auto-create = False</vh></v>
<v t="ekr.20240927151701.178"><vh>@bool view-rendered-auto-hide = False</vh></v>
<v t="ekr.20240927151701.179"><vh>@string view-rendered-default-kind = rst</vh></v>
</v>
</v>
<v t="ekr.20240927151701.203" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>Buttons</vh>
<v t="ekr.20240927151701.206"><vh>@button backup</vh></v>
<v t="ekr.20240927152759.1"><vh>@button cargo-run</vh></v>
<v t="ekr.20240927151701.207"><vh>@button print-gnx</vh></v>
</v>
</v>
<v t="ekr.20240927151245.1"><vh>@edit Cargo.toml</vh></v>
<v t="ekr.20240927151332.1"><vh>@file src/main.rs</vh></v>
<v t="ekr.20240927152759.1"></v>
</vnodes>
<tnodes>
<t tx="ekr.20240927151701.1"></t>
<t tx="ekr.20240927151701.100"></t>
<t tx="ekr.20240927151701.101"></t>
<t tx="ekr.20240927151701.102">vertical (v) or horizontal (h)

myLeoSettings.leo: vertical</t>
<t tx="ekr.20240927151701.103"></t>
<t tx="ekr.20240927151701.104"></t>
<t tx="ekr.20240927151701.105">@language rest
@wrap

See #3456.

</t>
<t tx="ekr.20240927151701.106"></t>
<t tx="ekr.20240927151701.107"></t>
<t tx="ekr.20240927151701.108"># leonine</t>
<t tx="ekr.20240927151701.109"></t>
<t tx="ekr.20240927151701.110"></t>
<t tx="ekr.20240927151701.111"></t>
<t tx="ekr.20240927151701.112"></t>
<t tx="ekr.20240927151701.113">True: (Recommended) Make a "Recovered Nodes" node whenever
Leo reads a file that has been changed outside of Leo.
</t>
<t tx="ekr.20240927151701.114"></t>
<t tx="ekr.20240927151701.115"></t>
<t tx="ekr.20240927151701.116"></t>
<t tx="ekr.20240927151701.117"></t>
<t tx="ekr.20240927151701.118"></t>
<t tx="ekr.20240927151701.119"></t>
<t tx="ekr.20240927151701.120"></t>
<t tx="ekr.20240927151701.121"></t>
<t tx="ekr.20240927151701.122"></t>
<t tx="ekr.20240927151701.123"></t>
<t tx="ekr.20240927151701.124"></t>
<t tx="ekr.20240927151701.126">Set to True to enable node appearance modifications
See tree-declutter-patterns
</t>
<t tx="ekr.20240927151701.144"></t>
<t tx="ekr.20240927151701.145">Only supported with the mod_tempfname.py plugin.

True: The plugin will store temporary files utilizing cleaner
file names (no unique number is appended to the node's headline text).
Unique temporary directory paths are used to insure unique files are
created by creating temporary directories reflecting each node's ancestor
nodes in the Leo outline. Note: Do not have multiple sibling nodes (nodes
having the same parent node) in Leo with the same headline text. There will
be a conflict if both are opened in an external editor at the same time.

False: The plugin will store temporary files with an appended
unique number to insure unique temporary filenames.
</t>
<t tx="ekr.20240927151701.146">True: check all @&lt;file&gt; nodes in the outline for changes in corresponding external files.</t>
<t tx="ekr.20240927151701.147"></t>
<t tx="ekr.20240927151701.148"></t>
<t tx="ekr.20240927151701.149"></t>
<t tx="ekr.20240927151701.150"></t>
<t tx="ekr.20240927151701.151"></t>
<t tx="ekr.20240927151701.152">It is *strange* to set this to True!</t>
<t tx="ekr.20240927151701.153">@language rest

To test #2041 &amp; #2094

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the search with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20240927151701.154">@language rest

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the seas with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20240927151701.155">Added on-popover to import-html-tags (for leovue)</t>
<t tx="ekr.20240927151701.156"># lowercase html tags, one per line.
# *** Add ons-popover tag for LeoVue.

a
abbr
acronym
address
applet
area
b
base
basefont
bdo
big
blockquote
body
br
button
caption
center
cite
code
col
colgroup
dd
del
dfn
dir
div
dl
dt
em
fieldset
font
form
frame
frameset
head
h1
h2
h3
h4
h5
h6
hr
html
i
iframe
img
input
ins
kbd
label
legend
li
link
map
menu
meta
noframes
noscript
object
ol
ons-popover
optgroup
option
p
param
pre
q
s
samp
script
select
small
span
strike
strong
style
sub
sup
table
tbody
td
textarea
tfoot
th
thead
title
tr
tt
u
ul
var</t>
<t tx="ekr.20240927151701.157"># lowercase xml tags, one per line.

html
body
head
div
table
</t>
<t tx="ekr.20240927151701.170" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e"># Recommended plugins, from leoSettings.leo:

plugins_menu.py
mod_scripting.py
nav_qt.py
viewrendered.py


# contextmenu.py      # Required by the vim.py and xemacs.py plugins.
</t>
<t tx="ekr.20240927151701.176"></t>
<t tx="ekr.20240927151701.177"># True: show vr pane when opening a file.</t>
<t tx="ekr.20240927151701.178"># True: hide the vr pane for text-only renderings.</t>
<t tx="ekr.20240927151701.179"></t>
<t tx="ekr.20240927151701.184"></t>
<t tx="ekr.20240927151701.190">Only difference from myLeoSettings.leo

Note: EKRWinowsDark.leo defines comment1_font

All three @color settings work.
The @font setting does not work.
</t>
<t tx="ekr.20240927151701.191">Bold</t>
<t tx="ekr.20240927151701.192">Italics</t>
<t tx="ekr.20240927151701.193"></t>
<t tx="ekr.20240927151701.194"># bold keywords defined in forth-bold-words</t>
<t tx="ekr.20240927151701.195"></t>
<t tx="ekr.20240927151701.196"># Note: the default font size is 12.
rest_comment1_family = None
rest_comment1_size = 12pt
rest_comment1_slant = italic
rest_comment1_weight = None
</t>
<t tx="ekr.20240927151701.202"># Note: Use jj instead of escape to end insert mode.</t>
<t tx="ekr.20240927151701.203" __bookmarks="7d7100580700000069735f6475706571014930300a732e"></t>
<t tx="ekr.20240927151701.206">@language python

"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='ekr-tbo-in-rust')
</t>
<t tx="ekr.20240927151701.207">@language python

print(p.gnx)</t>
<t tx="ekr.20240927151701.229">@language python
"""Recursively import all python files in a directory and clean the result."""
@tabwidth -4 # For a better match.
g.cls()
&lt;&lt; rust dir_list &gt;&gt;

dir_ = r'C:\Python\Python3.12\Lib\site-packages\coverage'
dir_ = r'C:\Python\Python3.12\Lib\site-packages\mypyc'
dir_ = r'C:\Python\Python3.12\Lib\site-packages\findimports.py'
dir_ = r'C:\Repos\ruff\crates'

c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    # '.html', '.js', '.json', '.py', '.rs', '.svg', '.ts', '.tsx']
    # '.codon', '.cpp', '.cc', '.el', '.scm',
    theTypes = ['.py', 'rs'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20240927151701.230">dir_list = (
    r'C:\Repos\RustPython\common\src',
    r'C:\Repos\RustPython\compiler\codegen\src',
    r'C:\Repos\RustPython\compiler\core\src',
    r'C:\Repos\RustPython\compiler\src',
    r'C:\Repos\RustPython\compiler\codegen\src',  # compile.rs: AST to bytecode.
    r'C:\Repos\RustPython\compiler\core\src', # bytecode.rs: implements bytecodes.
    
    r'C:\Repos\RustPython\derive\src',
    r'C:\Repos\RustPython\derive-impl\src',
    r'C:\Repos\RustPython\pylib\src',
    r'C:\Repos\RustPython\src',
    r'C:\Repos\RustPython\stdlib\src',
    r'C:\Repos\RustPython\vm\src', # compiler.rs.
    r'C:\Repos\RustPython\vm\src\stdlib', # *****ast.rs  Also, many .rs versions of stdlib.
    r'C:\Repos\RustPython\vm\src\vm',  # compile.rs.
    r'C:\Repos\RustPython\vm\src\stdlib\ast', # gen.rs automatically generated by ast/asdl_rs.py.
)
</t>
<t tx="ekr.20240927151701.44"></t>
<t tx="ekr.20240927151701.45"></t>
<t tx="ekr.20240927151701.46">
</t>
<t tx="ekr.20240927151701.47"></t>
<t tx="ekr.20240927151701.48"># This node contains the commands needed to execute a program in a particular language.

# Format: language-name: command

# Create a temporary file if c.p is not any kind of @&lt;file&gt; node.

# Compute the final command as follows:

# 1. If command contains &lt;FILE&gt;, replace &lt;FILE&gt; with the full path to the external file.
# 2. If command contains &lt;NO-FILE&gt;, just remove &lt;NO-FILE&gt;.
# 3. Otherwise, append the full path to the external file to the command.

go: go run . &lt;NO-FILE&gt;
python: python
rust: rustc
</t>
<t tx="ekr.20240927151701.49"># This node contains the regex pattern to determine the line number in error messages.
# Format: language-name: regex pattern
#
# Patterns must define two groups, in either order:
# One group, containing only digits, defines the line number.
# The other group defines the file name.

go: ^\s*(.*):([0-9]+):([0-9]+):.+$
python: ^\s*File "(.+)", line ([0-9]+), in .+$
rust: ^\s*--&gt; (.+):([0-9]+):([0-9]+)\s*$</t>
<t tx="ekr.20240927151701.50">cargo-run
backup
</t>
<t tx="ekr.20240927151701.51"># legacy: (default) Leo's legacy layout
# big-tree: replaces @bool big-outline-pane</t>
<t tx="ekr.20240927151701.63"></t>
<t tx="ekr.20240927151701.64"></t>
<t tx="ekr.20240927151701.65"># The headline must be: @outline-data tree-abbreviations

# A list tree abbreviation names.

# For each abbreviation name, there should be corresponding child node,
# the **abbreviation node** whose headline matches the abbreviation name.

# When a tree abbreviation fires, Leo pastes all the descendants of
# the abbreviation node as the last children of the presently selected node.

importer;;
per-commander-plugin;;
demo;;
</t>
<t tx="ekr.20240927151701.66"></t>
<t tx="ekr.20240927151701.67"></t>
<t tx="ekr.20240927151701.68"></t>
<t tx="ekr.20240927151701.69">'''
A template for demonstrations based on plugins/demo.py.
The demo;; abbreviation will create this tree.
'''
&lt;&lt; imports &gt;&gt;
@others
# Use the *same* command/key binding for demo-start and demo.next.
try:
    if getattr(g.app, 'demo', None):
        g.app.demo.next()
    else:
        g.cls()
        print('starting demo')
        demo = MyDemo(c, trace=False)
        demo.bind('callout', callout)
        demo.bind('title', title)
        demo.start(script_string=script_string)
except Exception:
    g.app.demo = None
    raise
</t>
<t tx="ekr.20240927151701.70">if c.isChanged(): c.save()
import imp
from leo.core.leoQt import QtGui
import leo.plugins.demo as demo_module
imp.reload(demo_module)</t>
<t tx="ekr.20240927151701.71"># A short example. Change as needed.
script_string = '''\
callout('Callout 1 centered')
title('This is title 1')
###
callout('Callout 2 (700, 200)', position=[700, 200])
title('This is title 2')
demo.next()
'''
</t>
<t tx="ekr.20240927151701.72">class MyDemo (demo_module.Demo):
    
    def setup_script(self):
        '''Delete all previously shown widgets.'''
        self.delete_widgets()</t>
<t tx="ekr.20240927151701.73">def callout(text, **keys):
    w = demo_module.Callout(text, **keys)
    
def title(text, **keys):
    w = demo_module.Title(text, **keys)
</t>
<t tx="ekr.20240927151701.74"></t>
<t tx="ekr.20240927151701.75">&lt;&lt; docstring &gt;&gt;
### From leoSettings.leo
# Created 2017/05/30
@language python
@tabwidth -4
__version__ = '0.0'
&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;
@others</t>
<t tx="ekr.20240927151701.76">'''
&lt;|docstring|&gt;
'''
</t>
<t tx="ekr.20240927151701.77">@
Put notes about each version here.
&lt;|Initial version notes|&gt;</t>
<t tx="ekr.20240927151701.78">import leo.core.leoGlobals as g

&lt;|imports|&gt;</t>
<t tx="ekr.20240927151701.79">def init ():
        
    ok = g.app.gui.guiName() in ('qt','qttabs')
    if ok:
        if 1: # Create the commander class *before* the frame is created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Create the commander class *after* the frame is created.
            g.registerHandler('after-create-leo-frame',onCreate)
        g.plugin_signon(__name__)   
    return ok
</t>
<t tx="ekr.20240927151701.80">def onCreate (tag, keys):
    
    c = keys.get('c')
    if c:
        thePluginController = pluginController(c)
</t>
<t tx="ekr.20240927151701.81">class &lt;|Controller Class Name|&gt;:
    
    @others</t>
<t tx="ekr.20240927151701.82">def __init__ (self,c):
    
    self.c = c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
    &lt;|ivars|&gt;</t>
<t tx="ekr.20240927151701.83"></t>
<t tx="ekr.20240927151701.84">'''
The @auto importer for the {|{x=get_language()}|} language.

Created {|{x=time.strftime("%Y/%m/%d")}|} by the `importer;;` abbreviation.
'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {|{x=cap_name}|}_Importer,
    'extensions': [&lt;|comma-separated lists of extensions|&gt;],
        # Example: ['.c', '.cc', '.c++', '.cpp', '.cxx', '.h', '.h++']
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20240927151701.85">class {|{x=cap_name}|}_Importer(Importer):
    '''The importer for the {|{x=name}|} language.'''

    def __init__(self, importCommands):
        '''{|{x=cap_name}|}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            language = '{|{x=name}|}',
            state_class = {|{x=cap_name}|}_ScanState,
            strict = &lt;|True leading whitespace is significant. Otherwise False|&gt;,
        )
        
    @others
</t>
<t tx="ekr.20240927151701.86"># These can be overridden in subclasses.
</t>
<t tx="ekr.20240927151701.87">### define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
# A more complex example, for the C language.

# def clean_headline(self, s):
    # '''Return a cleaned up headline s.'''
    # import re
    # type1 = r'(static|extern)*'
    # type2 = r'(void|int|float|double|char)*'
    # class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
    # pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
    # m = re.match(class_pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # return '%sclass %s' % (prefix1, m.group(2))
    # m = re.match(pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
        # h = m.group(3) or '&lt;no c function name&gt;'
        # return '%s%s%s' % (prefix1, prefix2, h)
    # else:
        # return s
</t>
<t tx="ekr.20240927151701.88">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an example.
    '''
    pass
</t>
<t tx="ekr.20240927151701.89">class {|{x=cap_name}|}_ScanState:
    '''A class representing the state of the {|{x=name}|} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{|{x=cap_name}|}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{|{x=cap_name}|}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{|{x=cap_name}|}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others

</t>
<t tx="ekr.20240927151701.9" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
<t tx="ekr.20240927151701.90">def level(self):
    '''{|{x=cap_name}|}_ScanState.level.'''
    return &lt;|self.curlies|&gt;
        ### Examples:
        # self.indent # for python, coffeescript.
        # self.curlies
        # (self, curlies, self.parens)
</t>
<t tx="ekr.20240927151701.91">def update(self, data):
    '''
    {|{x=cap_name}|}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {|{x=cap_name}|}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20240927151701.92"></t>
<t tx="ekr.20240927151701.93"></t>
<t tx="ekr.20240927151701.94">True: same as recent_files_group, except that even files (basenames) which are unique
have their containing path listed in the submenu - so visual clutter is reduced
but you can still see where things come from before you load them.

False: don't use submenus for multiple path entries, unless recent_files_group
is true (and recent_files_omit_directories is False)
</t>
<t tx="ekr.20240927151701.95"></t>
<t tx="ekr.20240927151701.96">True: show user tips on startup.</t>
<t tx="ekr.20240927151701.97"></t>
<t tx="ekr.20240927151701.98"></t>
<t tx="ekr.20240927151701.99"></t>
<t tx="ekr.20240927152759.1">@language python
g.cls()
import os
import subprocess

command = 'cargo run'
subprocess.Popen(command, shell=True).communicate()
</t>
<t tx="ekr.20240927153018.1"></t>
</tnodes>
</leo_file>
