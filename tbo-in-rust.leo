<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20240927151701.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735805000000302e302e3771067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c75735803000000302e31710d7d710e580b0000005f5f626f6f6b6d61726b73710f7d7110580700000069735f6475706571114930300a7373752e"><vh>Startup</vh>
<v t="ekr.20240927151701.9" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3771067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>@settings</vh>
<v t="ekr.20240927151701.44"><vh>@bool allow-text-zoom = True</vh></v>
<v t="ekr.20240927151701.45"><vh>@bool check-python-code-on-write = False</vh></v>
<v t="ekr.20240927151701.46"><vh>@bool use-german-keyboard = False</vh></v>
<v t="ekr.20240927151701.47"><vh>@bool use-mouse-expand-gestures = False</vh></v>
<v t="ekr.20240927151701.48"><vh>@data exec-script-commands</vh></v>
<v t="ekr.20240927151701.49"><vh>@data exec-script-patterns</vh></v>
<v t="ekr.20240927151701.50"><vh>@data history-list</vh></v>
<v t="ekr.20240927151701.170" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
<v t="ekr.20240927151701.51"><vh>@string qt-layout-name = legacy</vh></v>
<v t="ekr.20240927151701.63"><vh>Abbreviation settings</vh>
<v t="ekr.20240927151701.64"><vh>@bool enable-abbreviations = True</vh></v>
<v t="ekr.20240927151701.65"><vh>@outline-data tree-abbreviations</vh>
<v t="ekr.20240927151701.66"><vh>@organizer 1</vh>
<v t="ekr.20240927151701.67"><vh>@organizer 2</vh>
<v t="ekr.20240927151701.68"><vh>demo;;</vh>
<v t="ekr.20240927151701.69"><vh>@@button MyDemo @key=Ctrl-9</vh>
<v t="ekr.20240927151701.70"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20240927151701.71"><vh>script_string</vh></v>
<v t="ekr.20240927151701.72"><vh>class myDemo</vh></v>
<v t="ekr.20240927151701.73"><vh>wrappers</vh></v>
</v>
</v>
</v>
<v t="ekr.20240927151701.74"><vh>per-commander-plugin;;</vh>
<v t="ekr.20240927151701.75"><vh>@@file pluginname.py</vh>
<v t="ekr.20240927151701.76"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20240927151701.77"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20240927151701.78"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20240927151701.79"><vh>init</vh></v>
<v t="ekr.20240927151701.80"><vh>onCreate</vh></v>
<v t="ekr.20240927151701.81"><vh>class pluginController</vh>
<v t="ekr.20240927151701.82"><vh>__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20240927151701.83"><vh>importer;;</vh>
<v t="ekr.20240927151701.84"><vh>@@file importers/{|{x=name}|}.py</vh>
<v t="ekr.20240927151701.85"><vh>class {|{x=cap_name}|}_Importer</vh>
<v t="ekr.20240927151701.86"><vh>{|{x=name}|}.Overrides</vh>
<v t="ekr.20240927151701.87"><vh>{|{x=name}|}.clean_headline</vh></v>
<v t="ekr.20240927151701.88"><vh>{|{x=name}|}.clean_nodes</vh></v>
</v>
</v>
<v t="ekr.20240927151701.89"><vh>class class {|{x=cap_name}|}_ScanState</vh>
<v t="ekr.20240927151701.90"><vh>{|{x=name}|}_state.level</vh></v>
<v t="ekr.20240927151701.91"><vh>{|{x=name}|}_state.update</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20240927151701.92"><vh>Appearance settings</vh>
<v t="ekr.20240927151701.93"><vh>@bool log-pane-wraps = False</vh></v>
<v t="ekr.20240927151701.94"><vh>@bool recent-files-group-always = True</vh></v>
<v t="ekr.20240927151701.95"><vh>@bool show-iconbar = True</vh></v>
<v t="ekr.20240927151701.96"><vh>@bool show-tips = False</vh></v>
<v t="ekr.20240927151701.97"><vh>@bool stayInTreeAfterSelect = True</vh></v>
<v t="ekr.20240927151701.98"><vh>@bool use-chapter-tabs = False</vh></v>
<v t="ekr.20240927151701.99"><vh>@bool use-chapters = False</vh></v>
<v t="ekr.20240927151701.100"><vh>@bool use-gutter = False</vh></v>
<v t="ekr.20240927151701.101"><vh>@int qweb-view-font-size = 30</vh></v>
<v t="ekr.20240927151701.102"><vh>@string initial-split-orientation = v</vh></v>
</v>
<v t="ekr.20240927151701.103"><vh>Coloring settings</vh>
<v t="ekr.20240927151701.104"><vh>@bool color-doc-parts-as-rest = True</vh></v>
<v t="ekr.20240927151701.105"><vh>@bool use-pygments = False</vh></v>
<v t="ekr.20240927151701.106"><vh>@bool use-pygments-styles = False</vh></v>
<v t="ekr.20240927151701.107"><vh>@color head-bg = @mistyrose2</vh></v>
<v t="ekr.20240927151701.108"><vh>@string pygments-style-name = leonine</vh></v>
<v t="ekr.20240927151701.109"><vh>@string target-language = rust</vh></v>
</v>
<v t="ekr.20240927151701.110"><vh>Command settings</vh>
<v t="ekr.20240927151701.111"><vh>@bool create-at-persistence-nodes-automatically = False</vh></v>
<v t="ekr.20240927151701.112"><vh>@bool enable-persistence = False</vh></v>
<v t="ekr.20240927151701.113"><vh>@bool make-node-conflicts-node = True</vh></v>
<v t="ekr.20240927151701.184"><vh>@bool qt-use-scintilla = False</vh></v>
<v t="ekr.20240927151701.114"><vh>@bool run-pyflakes-on-write = False</vh></v>
<v t="ekr.20240927151701.126"><vh>@bool tree-declutter = False</vh></v>
<v t="ekr.20240927151701.115"><vh>@bool use-jedi = False</vh></v>
<v t="ekr.20240927151701.116"><vh>@bool use-qcompleter = False</vh></v>
<v t="ekr.20240927151701.202"><vh>@bool vim-mode = False</vh></v>
<v t="ekr.20240927151701.117"><vh>@bool warn-about-redefined-shortcuts = True</vh></v>
<v t="ekr.20240927151701.118"><vh>@int auto-justify = 80</vh></v>
<v t="ekr.20240927151701.119"><vh>rst3 path options</vh>
<v t="ekr.20240927151701.120"><vh>@string rst3-write-intermediate-extension = .txt</vh></v>
<v t="ekr.20240927151701.121"><vh>@string rst3-default-path = None</vh></v>
<v t="ekr.20240927151701.122"><vh>@string rst3-stylesheet-name = default.css</vh></v>
<v t="ekr.20240927151701.123"><vh>@string rst3-stylesheet-path = None</vh></v>
<v t="ekr.20240927151701.124"><vh>@string rst3-publish-argv-for-missing-stylesheets = None</vh></v>
</v>
</v>
<v t="ekr.20240927151701.144"><vh>File settings</vh>
<v t="ekr.20240927151701.145"><vh>@bool open-with-clean-filenames = True</vh></v>
<v t="ekr.20240927151701.146"><vh>@bool check-for-changed-external-files = True</vh></v>
<v t="ekr.20240927151701.147"><vh>@bool open-with-save-on-update = False</vh></v>
<v t="ekr.20240927151701.148"><vh>@bool open-with-uses-derived-file-extensions = True</vh></v>
</v>
<v t="ekr.20240927151701.149"><vh>Find settings</vh>
<v t="ekr.20240927151701.150"><vh>@bool auto-scroll-find-tab = False</vh></v>
<v t="ekr.20240927151701.151"><vh>@bool close-find-dialog-after-search = False</vh></v>
<v t="ekr.20240927151701.152"><vh>@bool find-ignore-duplicates = False</vh></v>
<v t="ekr.20240927151701.153"><vh>@bool minibuffer-find-mode = True</vh></v>
<v t="ekr.20240927151701.154"><vh>@bool use-find-dialog = False</vh></v>
</v>
<v t="ekr.20240927151701.155"><vh>Importer settings</vh>
<v t="ekr.20240927151701.156"><vh>@data import-html-tags</vh></v>
<v t="ekr.20240927151701.157"><vh>@data import-xml-tags</vh></v>
</v>
<v t="ekr.20240927153018.1"><vh>Scripts</vh>
<v t="ekr.20240927151701.229"><vh> Recursive import script</vh>
<v t="ekr.20240927151701.230"><vh>&lt;&lt; rust dir_list &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20240927151701.190"><vh>Syntax coloring settings</vh>
<v t="ekr.20240927151701.191"><vh>@@color rest.keyword2 = red</vh></v>
<v t="ekr.20240927151701.192"><vh>@@color rest.keyword4 = blue</vh></v>
<v t="ekr.20240927151701.193"><vh>@@color rest.leokeyword = green</vh></v>
<v t="ekr.20240927151701.194"><vh>@color forth.keyword3 = black</vh></v>
<v t="ekr.20240927151701.195"><vh>@color python.name = @solarized-yellow</vh></v>
<v t="ekr.20240927151701.196"><vh>@font rest.comment1</vh></v>
</v>
<v t="ekr.20240927151701.176"><vh>VR settings</vh>
<v t="ekr.20240927151701.177"><vh>@bool view-rendered-auto-create = False</vh></v>
<v t="ekr.20240927151701.178"><vh>@bool view-rendered-auto-hide = False</vh></v>
<v t="ekr.20240927151701.179"><vh>@string view-rendered-default-kind = rst</vh></v>
</v>
</v>
<v t="ekr.20240927151701.203" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>Buttons</vh>
<v t="ekr.20240927151701.206"><vh>@button backup</vh></v>
<v t="ekr.20240927152759.1"><vh>@button cargo-run</vh></v>
<v t="ekr.20240927151701.207"><vh>@button print-gnx</vh></v>
<v t="ekr.20240928073118.1"><vh>@button cargo-fmt</vh></v>
</v>
</v>
<v t="ekr.20240927164013.1"><vh>--- Pevious code</vh>
<v t="ekr.20240927163405.1"><vh>class Beautifier (from backup/rust_beautifier)</vh>
<v t="ekr.20240927163405.2"><vh>Beautifier::add_input_token</vh></v>
<v t="ekr.20240927163405.3"><vh>Beautifier::add_output_token</vh></v>
<v t="ekr.20240927163405.4"><vh>Beautifier::beautify_all_files</vh></v>
<v t="ekr.20240927163405.5"><vh>Beautifier::beautify_one_file</vh>
<v t="ekr.20240927163405.6"><vh>&lt;&lt; show output_list &gt;&gt;</vh></v>
</v>
<v t="ekr.20240927163405.7"><vh>Beautifier::do_*</vh>
<v t="ekr.20240927163405.8"><vh>Handlers with values</vh>
<v t="ekr.20240927163405.9"><vh>do_Comment</vh></v>
<v t="ekr.20240927163405.10"><vh>do_Complex</vh></v>
<v t="ekr.20240927163405.11"><vh>do_Float</vh></v>
<v t="ekr.20240927163405.12"><vh>do_Int</vh></v>
<v t="ekr.20240927163405.13"><vh>do_Name</vh></v>
<v t="ekr.20240927163405.14"><vh>do_String</vh></v>
</v>
<v t="ekr.20240927163405.15"><vh>Handlers using lws</vh>
<v t="ekr.20240927163405.16"><vh>do_Dedent</vh></v>
<v t="ekr.20240927163405.17"><vh>do_Indent</vh></v>
<v t="ekr.20240927163405.18"><vh>do_Newline</vh></v>
<v t="ekr.20240927163405.19"><vh>do_NonLogicalNewline</vh></v>
</v>
<v t="ekr.20240927163405.20"><vh>Handlers w/o values</vh>
<v t="ekr.20240927163405.21"><vh>do_Amper</vh></v>
<v t="ekr.20240927163405.22"><vh>do_AmperEqual</vh></v>
<v t="ekr.20240927163405.23"><vh>do_And</vh></v>
<v t="ekr.20240927163405.24"><vh>do_As</vh></v>
<v t="ekr.20240927163405.25"><vh>do_Assert</vh></v>
<v t="ekr.20240927163405.26"><vh>do_Async</vh></v>
<v t="ekr.20240927163405.27"><vh>do_At</vh></v>
<v t="ekr.20240927163405.28"><vh>do_AtEqual</vh></v>
<v t="ekr.20240927163405.29"><vh>do_Await</vh></v>
<v t="ekr.20240927163405.30"><vh>do_Break</vh></v>
<v t="ekr.20240927163405.31"><vh>do_Case</vh></v>
<v t="ekr.20240927163405.32"><vh>do_CircumFlex</vh></v>
<v t="ekr.20240927163405.33"><vh>do_CircumflexEqual</vh></v>
<v t="ekr.20240927163405.34"><vh>do_Class</vh></v>
<v t="ekr.20240927163405.35"><vh>do_Colon</vh></v>
<v t="ekr.20240927163405.36"><vh>do_ColonEqual</vh></v>
<v t="ekr.20240927163405.37"><vh>do_Comma</vh></v>
<v t="ekr.20240927163405.38"><vh>do_Continue</vh></v>
<v t="ekr.20240927163405.39"><vh>do_Def</vh></v>
<v t="ekr.20240927163405.40"><vh>do_Del</vh></v>
<v t="ekr.20240927163405.41"><vh>do_Dot</vh></v>
<v t="ekr.20240927163405.42"><vh>do_DoubleSlash</vh></v>
<v t="ekr.20240927163405.43"><vh>do_DoubleSlashEqual</vh></v>
<v t="ekr.20240927163405.44"><vh>do_DoubleStar</vh></v>
<v t="ekr.20240927163405.45"><vh>do_DoubleStarEqual</vh></v>
<v t="ekr.20240927163405.46"><vh>do_Elif</vh></v>
<v t="ekr.20240927163405.47"><vh>do_Ellipsis</vh></v>
<v t="ekr.20240927163405.48"><vh>do_Else</vh></v>
<v t="ekr.20240927163405.49"><vh>do_EndOfFile</vh></v>
<v t="ekr.20240927163405.50"><vh>do_EqEqual</vh></v>
<v t="ekr.20240927163405.51"><vh>do_Equal</vh></v>
<v t="ekr.20240927163405.52"><vh>do_Except</vh></v>
<v t="ekr.20240927163405.53"><vh>do_False</vh></v>
<v t="ekr.20240927163405.54"><vh>do_Finally</vh></v>
<v t="ekr.20240927163405.55"><vh>do_For</vh></v>
<v t="ekr.20240927163405.56"><vh>do_From</vh></v>
<v t="ekr.20240927163405.57"><vh>do_Global</vh></v>
<v t="ekr.20240927163405.58"><vh>do_Greater</vh></v>
<v t="ekr.20240927163405.59"><vh>do_GreaterEqual</vh></v>
<v t="ekr.20240927163405.60"><vh>do_If</vh></v>
<v t="ekr.20240927163405.61"><vh>do_Import</vh></v>
<v t="ekr.20240927163405.62"><vh>do_In</vh></v>
<v t="ekr.20240927163405.63"><vh>do_Is</vh></v>
<v t="ekr.20240927163405.64"><vh>do_Lambda</vh></v>
<v t="ekr.20240927163405.65"><vh>do_Lbrace</vh></v>
<v t="ekr.20240927163405.66"><vh>do_LeftShift</vh></v>
<v t="ekr.20240927163405.67"><vh>do_LeftShiftEqual</vh></v>
<v t="ekr.20240927163405.68"><vh>do_Less</vh></v>
<v t="ekr.20240927163405.69"><vh>do_LessEqual</vh></v>
<v t="ekr.20240927163405.70"><vh>do_Lpar</vh></v>
<v t="ekr.20240927163405.71"><vh>do_Lsqb</vh></v>
<v t="ekr.20240927163405.72"><vh>do_Match</vh></v>
<v t="ekr.20240927163405.73"><vh>do_Minus</vh></v>
<v t="ekr.20240927163405.74"><vh>do_MinusEqual</vh></v>
<v t="ekr.20240927163405.75"><vh>do_None</vh></v>
<v t="ekr.20240927163405.76"><vh>do_Nonlocal</vh></v>
<v t="ekr.20240927163405.77"><vh>do_Not</vh></v>
<v t="ekr.20240927163405.78"><vh>do_NotEqual</vh></v>
<v t="ekr.20240927163405.79"><vh>do_Or</vh></v>
<v t="ekr.20240927163405.80"><vh>do_Pass</vh></v>
<v t="ekr.20240927163405.81"><vh>do_Percent</vh></v>
<v t="ekr.20240927163405.82"><vh>do_PercentEqual</vh></v>
<v t="ekr.20240927163405.83"><vh>do_Plus</vh></v>
<v t="ekr.20240927163405.84"><vh>do_PlusEqual</vh></v>
<v t="ekr.20240927163405.85"><vh>do_Raise</vh></v>
<v t="ekr.20240927163405.86"><vh>do_Rarrow</vh></v>
<v t="ekr.20240927163405.87"><vh>do_Rbrace</vh></v>
<v t="ekr.20240927163405.88"><vh>do_Return</vh></v>
<v t="ekr.20240927163405.89"><vh>do_RightShift</vh></v>
<v t="ekr.20240927163405.90"><vh>do_RightShiftEqual</vh></v>
<v t="ekr.20240927163405.91"><vh>do_Rpar</vh></v>
<v t="ekr.20240927163405.92"><vh>do_Rsqb</vh></v>
<v t="ekr.20240927163405.93"><vh>do_Semi</vh></v>
<v t="ekr.20240927163405.94"><vh>do_Slash</vh></v>
<v t="ekr.20240927163405.95"><vh>do_SlashEqual</vh></v>
<v t="ekr.20240927163405.96"><vh>do_Star</vh></v>
<v t="ekr.20240927163405.97"><vh>do_StarEqual</vh></v>
<v t="ekr.20240927163405.98"><vh>do_StartExpression</vh></v>
<v t="ekr.20240927163405.99"><vh>do_StartInteractive</vh></v>
<v t="ekr.20240927163405.100"><vh>do_StarModule</vh></v>
<v t="ekr.20240927163405.101"><vh>do_Tilde</vh></v>
<v t="ekr.20240927163405.102"><vh>do_True</vh></v>
<v t="ekr.20240927163405.103"><vh>do_Try</vh></v>
<v t="ekr.20240927163405.104"><vh>do_Type</vh></v>
<v t="ekr.20240927163405.105"><vh>do_Vbar</vh></v>
<v t="ekr.20240927163405.106"><vh>do_VbarEqual</vh></v>
<v t="ekr.20240927163405.107"><vh>do_While</vh></v>
<v t="ekr.20240927163405.108"><vh>do_With</vh></v>
<v t="ekr.20240927163405.109"><vh>do_Yield</vh></v>
</v>
</v>
<v t="ekr.20240927163405.110"><vh>Beautifier::enabled</vh></v>
<v t="ekr.20240927163405.111"><vh>Beautifier::get_args</vh></v>
<v t="ekr.20240927163405.112"><vh>Beautifier::make_input_list</vh></v>
<v t="ekr.20240927163405.113"><vh>Beautifier::make_output_list</vh></v>
<v t="ekr.20240927163405.114"><vh>Beautifier::make_output_token</vh></v>
<v t="ekr.20240927163405.115"><vh>Beautifier::new</vh></v>
<v t="ekr.20240927163405.116"><vh>Beautifier::show_args</vh></v>
<v t="ekr.20240927163405.117"><vh>Beautifier::show_help</vh></v>
<v t="ekr.20240927163405.118"><vh>Beautifier::show_output_list</vh></v>
<v t="ekr.20240927163405.119"><vh>Beautifier::tokenize_contents</vh></v>
</v>
<v t="ekr.20240927163812.1"><vh>from leo-editor-contrib rust_beautifier.leo</vh>
<v t="ekr.20240927163855.1"><vh>@command test</vh></v>
<v t="ekr.20240927163907.1"><vh>Read Me</vh></v>
<v t="ekr.20240927163942.1"><vh>## @file src/leotokens.rs</vh>
<v t="ekr.20240927163942.2"><vh>&lt;&lt; leoTokens.rs: global suppressions &gt;&gt;</vh></v>
<v t="ekr.20240927163942.3"><vh>&lt;&lt; leoTokens.rs: use statements &gt;&gt;</vh></v>
<v t="ekr.20240927163942.4"><vh>Classes (leoTokens.rs)</vh>
<v t="ekr.20240927163942.5"><vh>class Beautifier </vh>
<v t="ekr.20240927163942.6"><vh>Beautifier::add_output_string</vh></v>
<v t="ekr.20240927163942.7"><vh>Beautifier::add_input_token</vh></v>
<v t="ekr.20240927163942.8"><vh>Beautifier::beautify_all_files</vh></v>
<v t="ekr.20240927163942.9"><vh>Beautifier::beautify_one_file</vh>
<v t="ekr.20240927163942.10"><vh>&lt;&lt; show output_list &gt;&gt;</vh></v>
</v>
<v t="ekr.20240927163942.11"><vh>Beautifier::do_*</vh>
<v t="ekr.20240927163942.12"><vh>Handlers with values</vh>
<v t="ekr.20240927163942.13"><vh>do_Comment</vh></v>
<v t="ekr.20240927163942.14"><vh>do_Complex</vh></v>
<v t="ekr.20240927163942.15"><vh>do_Float</vh></v>
<v t="ekr.20240927163942.16"><vh>do_Int</vh></v>
<v t="ekr.20240927163942.17"><vh>do_Name</vh></v>
<v t="ekr.20240927163942.18"><vh>do_String</vh></v>
</v>
<v t="ekr.20240927163942.19"><vh>Handlers using lws</vh>
<v t="ekr.20240927163942.20"><vh>do_Dedent</vh></v>
<v t="ekr.20240927163942.21"><vh>do_Indent</vh></v>
<v t="ekr.20240927163942.22"><vh>do_Newline</vh></v>
<v t="ekr.20240927163942.23"><vh>do_NonLogicalNewline</vh></v>
</v>
<v t="ekr.20240927163942.24"><vh>Handlers w/o values</vh>
<v t="ekr.20240927163942.25"><vh>do_Amper</vh></v>
<v t="ekr.20240927163942.26"><vh>do_AmperEqual</vh></v>
<v t="ekr.20240927163942.27"><vh>do_And</vh></v>
<v t="ekr.20240927163942.28"><vh>do_As</vh></v>
<v t="ekr.20240927163942.29"><vh>do_Assert</vh></v>
<v t="ekr.20240927163942.30"><vh>do_Async</vh></v>
<v t="ekr.20240927163942.31"><vh>do_At</vh></v>
<v t="ekr.20240927163942.32"><vh>do_AtEqual</vh></v>
<v t="ekr.20240927163942.33"><vh>do_Await</vh></v>
<v t="ekr.20240927163942.34"><vh>do_Break</vh></v>
<v t="ekr.20240927163942.35"><vh>do_Case</vh></v>
<v t="ekr.20240927163942.36"><vh>do_CircumFlex</vh></v>
<v t="ekr.20240927163942.37"><vh>do_CircumflexEqual</vh></v>
<v t="ekr.20240927163942.38"><vh>do_Class</vh></v>
<v t="ekr.20240927163942.39"><vh>do_Colon</vh></v>
<v t="ekr.20240927163942.40"><vh>do_ColonEqual</vh></v>
<v t="ekr.20240927163942.41"><vh>do_Comma</vh></v>
<v t="ekr.20240927163942.42"><vh>do_Continue</vh></v>
<v t="ekr.20240927163942.43"><vh>do_Def</vh></v>
<v t="ekr.20240927163942.44"><vh>do_Del</vh></v>
<v t="ekr.20240927163942.45"><vh>do_Dot</vh></v>
<v t="ekr.20240927163942.46"><vh>do_DoubleSlash</vh></v>
<v t="ekr.20240927163942.47"><vh>do_DoubleSlashEqual</vh></v>
<v t="ekr.20240927163942.48"><vh>do_DoubleStar</vh></v>
<v t="ekr.20240927163942.49"><vh>do_DoubleStarEqual</vh></v>
<v t="ekr.20240927163942.50"><vh>do_Elif</vh></v>
<v t="ekr.20240927163942.51"><vh>do_Ellipsis</vh></v>
<v t="ekr.20240927163942.52"><vh>do_Else</vh></v>
<v t="ekr.20240927163942.53"><vh>do_EndOfFile</vh></v>
<v t="ekr.20240927163942.54"><vh>do_EqEqual</vh></v>
<v t="ekr.20240927163942.55"><vh>do_Equal</vh></v>
<v t="ekr.20240927163942.56"><vh>do_Except</vh></v>
<v t="ekr.20240927163942.57"><vh>do_False</vh></v>
<v t="ekr.20240927163942.58"><vh>do_Finally</vh></v>
<v t="ekr.20240927163942.59"><vh>do_For</vh></v>
<v t="ekr.20240927163942.60"><vh>do_From</vh></v>
<v t="ekr.20240927163942.61"><vh>do_Global</vh></v>
<v t="ekr.20240927163942.62"><vh>do_Greater</vh></v>
<v t="ekr.20240927163942.63"><vh>do_GreaterEqual</vh></v>
<v t="ekr.20240927163942.64"><vh>do_If</vh></v>
<v t="ekr.20240927163942.65"><vh>do_Import</vh></v>
<v t="ekr.20240927163942.66"><vh>do_In</vh></v>
<v t="ekr.20240927163942.67"><vh>do_Is</vh></v>
<v t="ekr.20240927163942.68"><vh>do_Lambda</vh></v>
<v t="ekr.20240927163942.69"><vh>do_Lbrace</vh></v>
<v t="ekr.20240927163942.70"><vh>do_LeftShift</vh></v>
<v t="ekr.20240927163942.71"><vh>do_LeftShiftEqual</vh></v>
<v t="ekr.20240927163942.72"><vh>do_Less</vh></v>
<v t="ekr.20240927163942.73"><vh>do_LessEqual</vh></v>
<v t="ekr.20240927163942.74"><vh>do_Lpar</vh></v>
<v t="ekr.20240927163942.75"><vh>do_Lsqb</vh></v>
<v t="ekr.20240927163942.76"><vh>do_Match</vh></v>
<v t="ekr.20240927163942.77"><vh>do_Minus</vh></v>
<v t="ekr.20240927163942.78"><vh>do_MinusEqual</vh></v>
<v t="ekr.20240927163942.79"><vh>do_None</vh></v>
<v t="ekr.20240927163942.80"><vh>do_Nonlocal</vh></v>
<v t="ekr.20240927163942.81"><vh>do_Not</vh></v>
<v t="ekr.20240927163942.82"><vh>do_NotEqual</vh></v>
<v t="ekr.20240927163942.83"><vh>do_Or</vh></v>
<v t="ekr.20240927163942.84"><vh>do_Pass</vh></v>
<v t="ekr.20240927163942.85"><vh>do_Percent</vh></v>
<v t="ekr.20240927163942.86"><vh>do_PercentEqual</vh></v>
<v t="ekr.20240927163942.87"><vh>do_Plus</vh></v>
<v t="ekr.20240927163942.88"><vh>do_PlusEqual</vh></v>
<v t="ekr.20240927163942.89"><vh>do_Raise</vh></v>
<v t="ekr.20240927163942.90"><vh>do_Rarrow</vh></v>
<v t="ekr.20240927163942.91"><vh>do_Rbrace</vh></v>
<v t="ekr.20240927163942.92"><vh>do_Return</vh></v>
<v t="ekr.20240927163942.93"><vh>do_RightShift</vh></v>
<v t="ekr.20240927163942.94"><vh>do_RightShiftEqual</vh></v>
<v t="ekr.20240927163942.95"><vh>do_Rpar</vh></v>
<v t="ekr.20240927163942.96"><vh>do_Rsqb</vh></v>
<v t="ekr.20240927163942.97"><vh>do_Semi</vh></v>
<v t="ekr.20240927163942.98"><vh>do_Slash</vh></v>
<v t="ekr.20240927163942.99"><vh>do_SlashEqual</vh></v>
<v t="ekr.20240927163942.100"><vh>do_Star</vh></v>
<v t="ekr.20240927163942.101"><vh>do_StarEqual</vh></v>
<v t="ekr.20240927163942.102"><vh>do_StartExpression</vh></v>
<v t="ekr.20240927163942.103"><vh>do_StartInteractive</vh></v>
<v t="ekr.20240927163942.104"><vh>do_StarModule</vh></v>
<v t="ekr.20240927163942.105"><vh>do_Tilde</vh></v>
<v t="ekr.20240927163942.106"><vh>do_True</vh></v>
<v t="ekr.20240927163942.107"><vh>do_Try</vh></v>
<v t="ekr.20240927163942.108"><vh>do_Type</vh></v>
<v t="ekr.20240927163942.109"><vh>do_Vbar</vh></v>
<v t="ekr.20240927163942.110"><vh>do_VbarEqual</vh></v>
<v t="ekr.20240927163942.111"><vh>do_While</vh></v>
<v t="ekr.20240927163942.112"><vh>do_With</vh></v>
<v t="ekr.20240927163942.113"><vh>do_Yield</vh></v>
</v>
</v>
<v t="ekr.20240927163942.114"><vh>Beautifier::enabled</vh></v>
<v t="ekr.20240927163942.115"><vh>Beautifier::get_args</vh></v>
<v t="ekr.20240927163942.116"><vh>Beautifier::make_input_list</vh></v>
<v t="ekr.20240927163942.117"><vh>Beautifier::make_output_list</vh></v>
<v t="ekr.20240927163942.118"><vh>Beautifier::new</vh></v>
<v t="ekr.20240927163942.119"><vh>Beautifier::show_args</vh></v>
<v t="ekr.20240927163942.120"><vh>Beautifier::show_help</vh></v>
<v t="ekr.20240927163942.121"><vh>Beautifier::show_output_list</vh></v>
<v t="ekr.20240927163942.122"><vh>Beautifier::tokenize_contents (prototype)</vh></v>
</v>
<v t="ekr.20240927163942.123"><vh>class InputTok</vh></v>
</v>
<v t="ekr.20240927163942.124"><vh>pub fn entry &amp; helpers</vh>
<v t="ekr.20240927163942.125"><vh>fn tokenize</vh>
<v t="ekr.20240927163942.126"><vh>&lt;&lt; tokenize: define contents &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20240927163942.127"><vh>fn print_type &amp; type_of</vh></v>
</v>
</v>
</v>
<v t="ekr.20240927154009.1"><vh>Files</vh>
<v t="ekr.20240927151245.1"><vh>@edit Cargo.toml</vh></v>
<v t="ekr.20240927151332.1"><vh>@file src/main.rs</vh></v>
<v t="ekr.20240928161210.1"><vh>@file src/tbo.rs</vh></v>
</v>
<v t="ekr.20240927154016.1"><vh>Notes</vh></v>
<v t="ekr.20240927154323.1"><vh>** To do</vh></v>
<v t="ekr.20240927151332.1"></v>
<v t="ekr.20240928161210.1"></v>
<v t="ekr.20240928162805.1"><vh>git diff HEAD </vh>
<v t="ekr.20240928162805.2"><vh>diff: src/main.rs</vh>
<v t="ekr.20240928162805.7"><vh>diff: Changed</vh>
<v t="ekr.20240928162805.8"><vh>diff: src/main.rs</vh>
<v t="ekr.20240928162805.9"><vh>Old:src/main.rs</vh></v>
<v t="ekr.20240927151332.1"></v>
</v>
</v>
</v>
<v t="ekr.20240928162805.10"><vh>diff: tbo-in-rust.leo</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20240927151332.1">@language rust
// main.rs

#[macro_use]
extern crate fstrings;

mod tbo;

fn main() {
    tbo::entry();
}
</t>
<t tx="ekr.20240927151701.1"></t>
<t tx="ekr.20240927151701.100"></t>
<t tx="ekr.20240927151701.101"></t>
<t tx="ekr.20240927151701.102">vertical (v) or horizontal (h)

myLeoSettings.leo: vertical</t>
<t tx="ekr.20240927151701.103"></t>
<t tx="ekr.20240927151701.104"></t>
<t tx="ekr.20240927151701.105">@language rest
@wrap

See #3456.

</t>
<t tx="ekr.20240927151701.106"></t>
<t tx="ekr.20240927151701.107"></t>
<t tx="ekr.20240927151701.108"># leonine</t>
<t tx="ekr.20240927151701.109"></t>
<t tx="ekr.20240927151701.110"></t>
<t tx="ekr.20240927151701.111"></t>
<t tx="ekr.20240927151701.112"></t>
<t tx="ekr.20240927151701.113">True: (Recommended) Make a "Recovered Nodes" node whenever
Leo reads a file that has been changed outside of Leo.
</t>
<t tx="ekr.20240927151701.114"></t>
<t tx="ekr.20240927151701.115"></t>
<t tx="ekr.20240927151701.116"></t>
<t tx="ekr.20240927151701.117"></t>
<t tx="ekr.20240927151701.118"></t>
<t tx="ekr.20240927151701.119"></t>
<t tx="ekr.20240927151701.120"></t>
<t tx="ekr.20240927151701.121"></t>
<t tx="ekr.20240927151701.122"></t>
<t tx="ekr.20240927151701.123"></t>
<t tx="ekr.20240927151701.124"></t>
<t tx="ekr.20240927151701.126">Set to True to enable node appearance modifications
See tree-declutter-patterns
</t>
<t tx="ekr.20240927151701.144"></t>
<t tx="ekr.20240927151701.145">Only supported with the mod_tempfname.py plugin.

True: The plugin will store temporary files utilizing cleaner
file names (no unique number is appended to the node's headline text).
Unique temporary directory paths are used to insure unique files are
created by creating temporary directories reflecting each node's ancestor
nodes in the Leo outline. Note: Do not have multiple sibling nodes (nodes
having the same parent node) in Leo with the same headline text. There will
be a conflict if both are opened in an external editor at the same time.

False: The plugin will store temporary files with an appended
unique number to insure unique temporary filenames.
</t>
<t tx="ekr.20240927151701.146">True: check all @&lt;file&gt; nodes in the outline for changes in corresponding external files.</t>
<t tx="ekr.20240927151701.147"></t>
<t tx="ekr.20240927151701.148"></t>
<t tx="ekr.20240927151701.149"></t>
<t tx="ekr.20240927151701.150"></t>
<t tx="ekr.20240927151701.151"></t>
<t tx="ekr.20240927151701.152">It is *strange* to set this to True!</t>
<t tx="ekr.20240927151701.153">@language rest

To test #2041 &amp; #2094

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the search with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20240927151701.154">@language rest

The @bool use-find-dialog and @bool minibuffer-find-mode settings comprise
a tri-state setting, as shown in this table:
    
minibuffer-find-mode    use-find-dialog     mode: Ctrl-F puts focus in
--------------------    ---------------     --------------------------
    True                    Ignored         minibuffer
    False                   True            dialog
    False                   False           Find tab in the log pane

*All modes*

- Start the seas with Ctrl-F (start-search).
- Enter the find pattern.
- (Optional) Use &lt;Tab&gt; to enter the search pattern.
- Use &lt;Enter&gt; to start the search.

*dialog and find tab modes*

- Non-functional "buttons" remind you of key bindings.

*minibuffer mode*

- Use Ctrl-G as always to leave the minibuffer.
- The Find tab is not made visible, but the status area shows the settings.</t>
<t tx="ekr.20240927151701.155">Added on-popover to import-html-tags (for leovue)</t>
<t tx="ekr.20240927151701.156"># lowercase html tags, one per line.
# *** Add ons-popover tag for LeoVue.

a
abbr
acronym
address
applet
area
b
base
basefont
bdo
big
blockquote
body
br
button
caption
center
cite
code
col
colgroup
dd
del
dfn
dir
div
dl
dt
em
fieldset
font
form
frame
frameset
head
h1
h2
h3
h4
h5
h6
hr
html
i
iframe
img
input
ins
kbd
label
legend
li
link
map
menu
meta
noframes
noscript
object
ol
ons-popover
optgroup
option
p
param
pre
q
s
samp
script
select
small
span
strike
strong
style
sub
sup
table
tbody
td
textarea
tfoot
th
thead
title
tr
tt
u
ul
var</t>
<t tx="ekr.20240927151701.157"># lowercase xml tags, one per line.

html
body
head
div
table
</t>
<t tx="ekr.20240927151701.170" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e"># Recommended plugins, from leoSettings.leo:

plugins_menu.py
mod_scripting.py
nav_qt.py
viewrendered.py


# contextmenu.py      # Required by the vim.py and xemacs.py plugins.
</t>
<t tx="ekr.20240927151701.176"></t>
<t tx="ekr.20240927151701.177"># True: show vr pane when opening a file.</t>
<t tx="ekr.20240927151701.178"># True: hide the vr pane for text-only renderings.</t>
<t tx="ekr.20240927151701.179"></t>
<t tx="ekr.20240927151701.184"></t>
<t tx="ekr.20240927151701.190">Only difference from myLeoSettings.leo

Note: EKRWinowsDark.leo defines comment1_font

All three @color settings work.
The @font setting does not work.
</t>
<t tx="ekr.20240927151701.191">Bold</t>
<t tx="ekr.20240927151701.192">Italics</t>
<t tx="ekr.20240927151701.193"></t>
<t tx="ekr.20240927151701.194"># bold keywords defined in forth-bold-words</t>
<t tx="ekr.20240927151701.195"></t>
<t tx="ekr.20240927151701.196"># Note: the default font size is 12.
rest_comment1_family = None
rest_comment1_size = 12pt
rest_comment1_slant = italic
rest_comment1_weight = None
</t>
<t tx="ekr.20240927151701.202"># Note: Use jj instead of escape to end insert mode.</t>
<t tx="ekr.20240927151701.203" __bookmarks="7d7100580700000069735f6475706571014930300a732e"></t>
<t tx="ekr.20240927151701.206">@language python

"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='ekr-tbo-in-rust')
</t>
<t tx="ekr.20240927151701.207">@language python

print(p.gnx)</t>
<t tx="ekr.20240927151701.229">@language python
"""Recursively import all python files in a directory and clean the result."""
@tabwidth -4 # For a better match.
g.cls()
&lt;&lt; rust dir_list &gt;&gt;

dir_ = r'C:\Python\Python3.12\Lib\site-packages\coverage'
dir_ = r'C:\Python\Python3.12\Lib\site-packages\mypyc'
dir_ = r'C:\Python\Python3.12\Lib\site-packages\findimports.py'
dir_ = r'C:\Repos\ruff\crates'

c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    # '.html', '.js', '.json', '.py', '.rs', '.svg', '.ts', '.tsx']
    # '.codon', '.cpp', '.cc', '.el', '.scm',
    theTypes = ['.py', 'rs'],
    verbose = False,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20240927151701.230">dir_list = (
    r'C:\Repos\RustPython\common\src',
    r'C:\Repos\RustPython\compiler\codegen\src',
    r'C:\Repos\RustPython\compiler\core\src',
    r'C:\Repos\RustPython\compiler\src',
    r'C:\Repos\RustPython\compiler\codegen\src',  # compile.rs: AST to bytecode.
    r'C:\Repos\RustPython\compiler\core\src', # bytecode.rs: implements bytecodes.
    
    r'C:\Repos\RustPython\derive\src',
    r'C:\Repos\RustPython\derive-impl\src',
    r'C:\Repos\RustPython\pylib\src',
    r'C:\Repos\RustPython\src',
    r'C:\Repos\RustPython\stdlib\src',
    r'C:\Repos\RustPython\vm\src', # compiler.rs.
    r'C:\Repos\RustPython\vm\src\stdlib', # *****ast.rs  Also, many .rs versions of stdlib.
    r'C:\Repos\RustPython\vm\src\vm',  # compile.rs.
    r'C:\Repos\RustPython\vm\src\stdlib\ast', # gen.rs automatically generated by ast/asdl_rs.py.
)
</t>
<t tx="ekr.20240927151701.44"></t>
<t tx="ekr.20240927151701.45"></t>
<t tx="ekr.20240927151701.46">
</t>
<t tx="ekr.20240927151701.47"></t>
<t tx="ekr.20240927151701.48"># This node contains the commands needed to execute a program in a particular language.

# Format: language-name: command

# Create a temporary file if c.p is not any kind of @&lt;file&gt; node.

# Compute the final command as follows:

# 1. If command contains &lt;FILE&gt;, replace &lt;FILE&gt; with the full path to the external file.
# 2. If command contains &lt;NO-FILE&gt;, just remove &lt;NO-FILE&gt;.
# 3. Otherwise, append the full path to the external file to the command.

go: go run . &lt;NO-FILE&gt;
python: python
rust: rustc
</t>
<t tx="ekr.20240927151701.49"># This node contains the regex pattern to determine the line number in error messages.
# Format: language-name: regex pattern
#
# Patterns must define two groups, in either order:
# One group, containing only digits, defines the line number.
# The other group defines the file name.

go: ^\s*(.*):([0-9]+):([0-9]+):.+$
python: ^\s*File "(.+)", line ([0-9]+), in .+$
rust: ^\s*--&gt; (.+):([0-9]+):([0-9]+)\s*$</t>
<t tx="ekr.20240927151701.50">cargo-run
backup
</t>
<t tx="ekr.20240927151701.51"># legacy: (default) Leo's legacy layout
# big-tree: replaces @bool big-outline-pane</t>
<t tx="ekr.20240927151701.63"></t>
<t tx="ekr.20240927151701.64"></t>
<t tx="ekr.20240927151701.65"># The headline must be: @outline-data tree-abbreviations

# A list tree abbreviation names.

# For each abbreviation name, there should be corresponding child node,
# the **abbreviation node** whose headline matches the abbreviation name.

# When a tree abbreviation fires, Leo pastes all the descendants of
# the abbreviation node as the last children of the presently selected node.

importer;;
per-commander-plugin;;
demo;;
</t>
<t tx="ekr.20240927151701.66"></t>
<t tx="ekr.20240927151701.67"></t>
<t tx="ekr.20240927151701.68"></t>
<t tx="ekr.20240927151701.69">'''
A template for demonstrations based on plugins/demo.py.
The demo;; abbreviation will create this tree.
'''
&lt;&lt; imports &gt;&gt;
@others
# Use the *same* command/key binding for demo-start and demo.next.
try:
    if getattr(g.app, 'demo', None):
        g.app.demo.next()
    else:
        g.cls()
        print('starting demo')
        demo = MyDemo(c, trace=False)
        demo.bind('callout', callout)
        demo.bind('title', title)
        demo.start(script_string=script_string)
except Exception:
    g.app.demo = None
    raise
</t>
<t tx="ekr.20240927151701.70">if c.isChanged(): c.save()
import imp
from leo.core.leoQt import QtGui
import leo.plugins.demo as demo_module
imp.reload(demo_module)</t>
<t tx="ekr.20240927151701.71"># A short example. Change as needed.
script_string = '''\
callout('Callout 1 centered')
title('This is title 1')
###
callout('Callout 2 (700, 200)', position=[700, 200])
title('This is title 2')
demo.next()
'''
</t>
<t tx="ekr.20240927151701.72">class MyDemo (demo_module.Demo):
    
    def setup_script(self):
        '''Delete all previously shown widgets.'''
        self.delete_widgets()</t>
<t tx="ekr.20240927151701.73">def callout(text, **keys):
    w = demo_module.Callout(text, **keys)
    
def title(text, **keys):
    w = demo_module.Title(text, **keys)
</t>
<t tx="ekr.20240927151701.74"></t>
<t tx="ekr.20240927151701.75">&lt;&lt; docstring &gt;&gt;
### From leoSettings.leo
# Created 2017/05/30
@language python
@tabwidth -4
__version__ = '0.0'
&lt;&lt; version history &gt;&gt;
&lt;&lt; imports &gt;&gt;
@others</t>
<t tx="ekr.20240927151701.76">'''
&lt;|docstring|&gt;
'''
</t>
<t tx="ekr.20240927151701.77">@
Put notes about each version here.
&lt;|Initial version notes|&gt;</t>
<t tx="ekr.20240927151701.78">import leo.core.leoGlobals as g

&lt;|imports|&gt;</t>
<t tx="ekr.20240927151701.79">def init ():
        
    ok = g.app.gui.guiName() in ('qt','qttabs')
    if ok:
        if 1: # Create the commander class *before* the frame is created.
            g.registerHandler('before-create-leo-frame',onCreate)
        else: # Create the commander class *after* the frame is created.
            g.registerHandler('after-create-leo-frame',onCreate)
        g.plugin_signon(__name__)   
    return ok
</t>
<t tx="ekr.20240927151701.80">def onCreate (tag, keys):
    
    c = keys.get('c')
    if c:
        thePluginController = pluginController(c)
</t>
<t tx="ekr.20240927151701.81">class &lt;|Controller Class Name|&gt;:
    
    @others</t>
<t tx="ekr.20240927151701.82">def __init__ (self,c):
    
    self.c = c
    # Warning: hook handlers must use keywords.get('c'), NOT self.c.
    &lt;|ivars|&gt;</t>
<t tx="ekr.20240927151701.83"></t>
<t tx="ekr.20240927151701.84">'''
The @auto importer for the {|{x=get_language()}|} language.

Created {|{x=time.strftime("%Y/%m/%d")}|} by the `importer;;` abbreviation.
'''
import leo.plugins.importers.linescanner as linescanner
Importer = linescanner.Importer
@others
importer_dict = {
    'class': {|{x=cap_name}|}_Importer,
    'extensions': [&lt;|comma-separated lists of extensions|&gt;],
        # Example: ['.c', '.cc', '.c++', '.cpp', '.cxx', '.h', '.h++']
}
@language python
@tabwidth -4


</t>
<t tx="ekr.20240927151701.85">class {|{x=cap_name}|}_Importer(Importer):
    '''The importer for the {|{x=name}|} language.'''

    def __init__(self, importCommands):
        '''{|{x=cap_name}|}_Importer.__init__'''
        # Init the base class.
        Importer.__init__(self,
            importCommands,
            language = '{|{x=name}|}',
            state_class = {|{x=cap_name}|}_ScanState,
            strict = &lt;|True leading whitespace is significant. Otherwise False|&gt;,
        )
        
    @others
</t>
<t tx="ekr.20240927151701.86"># These can be overridden in subclasses.
</t>
<t tx="ekr.20240927151701.87">### define an override if desired...

if 0: # The base class
    def clean_headline(self, s):
        '''Return a cleaned up headline s.'''
        return s.strip()
        
# A more complex example, for the C language.

# def clean_headline(self, s):
    # '''Return a cleaned up headline s.'''
    # import re
    # type1 = r'(static|extern)*'
    # type2 = r'(void|int|float|double|char)*'
    # class_pattern = r'\s*(%s)\s*class\s+(\w+)' % (type1)
    # pattern = r'\s*(%s)\s*(%s)\s*(\w+)' % (type1, type2)
    # m = re.match(class_pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # return '%sclass %s' % (prefix1, m.group(2))
    # m = re.match(pattern, s)
    # if m:
        # prefix1 = '%s ' % (m.group(1)) if m.group(1) else ''
        # prefix2 = '%s ' % (m.group(2)) if m.group(2) else ''
        # h = m.group(3) or '&lt;no c function name&gt;'
        # return '%s%s%s' % (prefix1, prefix2, h)
    # else:
        # return s
</t>
<t tx="ekr.20240927151701.88">def clean_nodes(self, parent):
    '''
    Clean all nodes in parent's tree.
    Subclasses override this as desired.
    See perl_i.clean_nodes for an example.
    '''
    pass
</t>
<t tx="ekr.20240927151701.89">class {|{x=cap_name}|}_ScanState:
    '''A class representing the state of the {|{x=name}|} line-oriented scan.'''
    
    def __init__(self, d=None):
        '''{|{x=cap_name}|}_ScanState.__init__'''
        if d:
            prev = d.get('prev')
            self.context = prev.context
            ### Adjust these by hand.
            self.curlies = prev.curlies
        else:
            self.context = ''
            ### Adjust these by hand.
            self.curlies = 0

    def __repr__(self):
        '''{|{x=cap_name}|}_ScanState.__repr__'''
        ### Adjust these by hand.
        return "{|{x=cap_name}|}_ScanState context: %r curlies: %s" % (
            self.context, self.curlies)

    __str__ = __repr__

    @others

</t>
<t tx="ekr.20240927151701.9" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
<t tx="ekr.20240927151701.90">def level(self):
    '''{|{x=cap_name}|}_ScanState.level.'''
    return &lt;|self.curlies|&gt;
        ### Examples:
        # self.indent # for python, coffeescript.
        # self.curlies
        # (self, curlies, self.parens)
</t>
<t tx="ekr.20240927151701.91">def update(self, data):
    '''
    {|{x=cap_name}|}_ScanState.update

    Update the state using the 6-tuple returned by v2_scan_line.
    Return i = data[1]
    '''
    context, i, delta_c, delta_p, delta_s, bs_nl = data
    # All ScanState classes must have a context ivar.
    self.context = context
    self.curlies += delta_c  
    ### Update {|{x=cap_name}|}_ScanState ivars
    # self.bs_nl = bs_nl
    # self.parens += delta_p
    # self.squares += delta_s
    return i
</t>
<t tx="ekr.20240927151701.92"></t>
<t tx="ekr.20240927151701.93"></t>
<t tx="ekr.20240927151701.94">True: same as recent_files_group, except that even files (basenames) which are unique
have their containing path listed in the submenu - so visual clutter is reduced
but you can still see where things come from before you load them.

False: don't use submenus for multiple path entries, unless recent_files_group
is true (and recent_files_omit_directories is False)
</t>
<t tx="ekr.20240927151701.95"></t>
<t tx="ekr.20240927151701.96">True: show user tips on startup.</t>
<t tx="ekr.20240927151701.97"></t>
<t tx="ekr.20240927151701.98"></t>
<t tx="ekr.20240927151701.99"></t>
<t tx="ekr.20240927152759.1">@language python
g.cls()
import os
import subprocess

if c.changed:
    c.save()

command = 'cargo run'
subprocess.Popen(command, shell=True).communicate()
</t>
<t tx="ekr.20240927153018.1"></t>
<t tx="ekr.20240927154009.1"></t>
<t tx="ekr.20240927154016.1">@language rest
@nowrap

code:

ekr-tbo-in-rust: https://github.com/edreamleo/ekr-tbo-in-rust
ruff_python_parser: https://github.com/astral-sh/ruff/tree/main/crates/ruff_python_parser/src
lexer.rs: https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_parser/src/lexer.rs

docs:
Rust Book: https://doc.rust-lang.org/stable/book/title-page.html
</t>
<t tx="ekr.20240927154323.1">@language rest
@wrap

Proof of concept:

- Add virtual ws tokens.
- Create the gem.</t>
<t tx="ekr.20240927163405.1">#[derive(Debug)]
pub struct Beautifier {
    args: Vec&lt;String&gt;,
    files_list: Vec&lt;String&gt;,
    input_list: Vec&lt;InputTok&gt;,
    output_list: Vec&lt;OutputTok&gt;,
}

///// Temporary.
#[allow(dead_code)]
#[allow(non_snake_case)]
impl Beautifier {
    @others
}
</t>
<t tx="ekr.20240927163405.10">fn do_Complex(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Complex", tok_value);
}
</t>
<t tx="ekr.20240927163405.100">fn do_StartModule(&amp;mut self) {
    // self.add_output_token("StartModule", "");
    println!("do_StartModule");
}
</t>
<t tx="ekr.20240927163405.101">fn do_Tilde(&amp;mut self) {
    self.add_output_token("Tilde", "~");
}
</t>
<t tx="ekr.20240927163405.102">fn do_True(&amp;mut self) {
    self.add_output_token("True", "True");
}
</t>
<t tx="ekr.20240927163405.103">fn do_Try(&amp;mut self) {
    self.add_output_token("Try", "try");
}
</t>
<t tx="ekr.20240927163405.104">fn do_Type(&amp;mut self) {
    self.add_output_token("Type", "type");
}
</t>
<t tx="ekr.20240927163405.105">fn do_Vbar(&amp;mut self) {
    self.add_output_token("Vbar", "|");
}
</t>
<t tx="ekr.20240927163405.106">fn do_VbarEqual(&amp;mut self) {
    self.add_output_token("VbarEqual", "|=");
}
</t>
<t tx="ekr.20240927163405.107">fn do_While(&amp;mut self) {
    self.add_output_token("While", "while");
}
</t>
<t tx="ekr.20240927163405.108">fn do_With(&amp;mut self) {
    self.add_output_token("With", "with");
}
</t>
<t tx="ekr.20240927163405.109">fn do_Yield(&amp;mut self) {
    self.add_output_token("Yield", "yield");
}
</t>
<t tx="ekr.20240927163405.11">fn do_Float(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Float", tok_value);
}
</t>
<t tx="ekr.20240927163405.110">fn enabled(&amp;self, arg: &amp;str) -&gt; bool {
    //! Beautifier::enabled: return true if the given command-line argument is enabled.
    //! Example:  x.enabled("--report");
    return self.args.contains(&amp;arg.to_string());

}
</t>
<t tx="ekr.20240927163405.111">fn get_args(&amp;mut self) {
    //! Beautifier::get_args: Set the args and files_list ivars.
    let args: Vec&lt;String&gt; = env::args().collect();
    let valid_args = vec![
        "--all", 
        "--beautified",
        "--diff",
        "-h", "--help",
        "--report",
        "--write",
    ];
    for (i, arg) in args.iter().enumerate() {
        if i &gt; 0 {
            if valid_args.contains(&amp;arg.as_str()) {
                self.args.push(arg.to_string())
            }
            else if 
                arg.as_str().starts_with("--") ||
                arg.as_str().starts_with("--")
            {
                println!("Ignoring invalid arg: {arg}");
            }
            else {
                println!("File: {arg}");
                self.files_list.push(arg.to_string());
            }
        }
    }
}
</t>
<t tx="ekr.20240927163405.112">fn make_input_list(&amp;mut self, contents: &amp;str) -&gt; u32 {

    let mut count: u32 = 0;
    let results = lex(&amp;contents, Mode::Module);  // An iterator yielding Option(Tok).
    for result in results {
        use Tok::*;
        count += 1;
        let token = result.ok().unwrap();
        let (ref tok_class, tok_range) = token;
        let tok_value = &amp;contents[tok_range];

        // Variants names are necessary, but otherwise not used.
        #[allow(unused_variables)]
        let class_name = match tok_class {
            // Tokens with values...
            // Use tok_value for *all* values.
            Comment(value) =&gt; "Comment",  // No idea why parens are needed here.
            Complex { real, imag } =&gt; "Complex",
            Float { value } =&gt; "Float",
            Int { value } =&gt; "Int",
            Name { name } =&gt; "Name",
            Tok::String { value, kind, triple_quoted } =&gt; "String",
            
            // Common tokens...
            Class =&gt; "Class",
            Dedent =&gt; "Dedent",
            Def =&gt; "Def",
            Indent =&gt; "Indent",
            Newline =&gt; "Newline",
            NonLogicalNewline =&gt; "NonLogicalNewline",

            // All other tokens...
            Amper =&gt; "Amper",
            AmperEqual =&gt; "AmperEqual",
            And =&gt; "And",
            As =&gt; "As",
            Assert =&gt; "Assert",
            Async =&gt; "Async",
            At =&gt; "At",
            AtEqual =&gt; "AtEqual",
            Await =&gt; "Await",
            Break =&gt; "Break",
            Case =&gt; "Case",
            CircumFlex =&gt; "CircumFlex",
            CircumflexEqual =&gt; "CircumflexEqual",
            Colon =&gt; "Colon",
            ColonEqual =&gt; "ColonEqual",
            Comma =&gt; "Comma",
            Continue =&gt; "Continue",
            Del =&gt; "Del",
            Dot =&gt; "Dot",
            DoubleSlash =&gt; "DoubleSlash",
            DoubleSlashEqual =&gt; "DoubleSlashEqual",
            DoubleStar =&gt; "DoubleStar",
            DoubleStarEqual =&gt; "DoubleStarEqual",
            Elif =&gt; "Elif",
            Ellipsis =&gt; "Ellipsis",
            Else =&gt; "Else",
            EndOfFile =&gt; "EndOfFile",
            EqEqual =&gt; "EqEqual",
            Equal =&gt; "Equal",
            Except =&gt; "Except",
            False =&gt; "False",
            Finally =&gt; "Finally",
            For =&gt; "For",
            From =&gt; "From",
            Global =&gt; "Global",
            Greater =&gt; "Greater",
            GreaterEqual =&gt; "GreaterEqual",
            If =&gt; "If",
            Import =&gt; "Import",
            In =&gt; "In",
            Is =&gt; "Is",
            Lambda =&gt; "Lambda",
            Lbrace =&gt; "Lbrace",
            LeftShift =&gt; "LeftShift",
            LeftShiftEqual =&gt; "LeftShiftEqual",
            Less =&gt; "Less",
            LessEqual =&gt; "LessEqual",
            Lpar =&gt; "Lpar",
            Lsqb =&gt; "Lsqb",
            Match =&gt; "Match",
            Minus =&gt; "Minus",
            MinusEqual =&gt; "MinusEqual",
            None =&gt; "None",
            Nonlocal =&gt; "Nonlocal",
            Not =&gt; "Not",
            NotEqual =&gt; "NotEqual",
            Or =&gt; "Or",
            Pass =&gt; "Pass",
            Percent =&gt; "Percent",
            PercentEqual =&gt; "PercentEqual",
            Plus =&gt; "Plus",
            PlusEqual =&gt; "PlusEqual",
            Raise =&gt; "Raise",
            Rarrow =&gt; "Rarrow",
            Rbrace =&gt; "Rbrace",
            Return =&gt; "Return",
            RightShift =&gt; "RightShift",
            RightShiftEqual =&gt; "RightShiftEqual",
            Rpar =&gt; "Rpar",
            Rsqb =&gt; "Rsqb",
            Semi =&gt; "Semi",
            Slash =&gt; "Slash",
            SlashEqual =&gt; "SlashEqual",
            Star =&gt; "Star",
            StarEqual =&gt; "StarEqual",
            StartExpression =&gt; "StartExpression",
            StartInteractive =&gt; "StartInteractive",
            StartModule =&gt; "StartModule",
            Tilde =&gt; "Tilde",
            True =&gt; "True",
            Try =&gt; "Try",
            Type =&gt; "Type",
            Vbar =&gt; "Vbar",
            VbarEqual =&gt; "VbarEqual",
            While =&gt; "While",
            With =&gt; "With",
            Yield =&gt; "Yield",
        };
        self.add_input_token(class_name, tok_value);
    }
    return count;
}
</t>
<t tx="ekr.20240927163405.113">fn make_output_list(&amp;mut self) {

    //// let mut lws = String::new();

    // for input_token in self.input_list.iter() {
    for input_token in &amp;self.input_list.clone() {
        // println!("{:?}", input_token);
        self.make_output_token(input_token);
    }
}
</t>
<t tx="ekr.20240927163405.114">fn make_output_token(&amp;mut self, input_token: &amp;InputTok) {
    self.add_output_token (input_token.kind.as_str(), input_token.value.as_str());
}
</t>
<t tx="ekr.20240927163405.115">pub fn new() -&gt; Beautifier {
    let mut x = Beautifier {
        args: Vec::new(),
        files_list: Vec::new(),
        input_list: Vec::new(),
        output_list: Vec::new(),
    };
    x.get_args();
    return x;
}
</t>
<t tx="ekr.20240927163405.116">fn show_args (&amp;self) {
    println!("Command-line arguments...");
    for (i, arg) in self.args.iter().enumerate() {
        if i &gt; 0 {
            println!("  {arg}");
        }
    }
    for file_arg in self.files_list.iter() {
        println!("  {file_arg}");
    }
}
</t>
<t tx="ekr.20240927163405.117">fn show_help (&amp;self) {
    //! Beautifier::show_help: print the help messages.
    println!("{}", textwrap::dedent("
        Beautify or diff files.

        -h --help:      Print this help message and exit.
        --all:          Beautify all files, even unchanged files.
        --beautified:   Report beautified files individually, even if not written.
        --diff:         Show diffs instead of changing files.
        --report:       Print summary report.
        --write:        Write beautifed files (dry-run mode otherwise).
    "));
}
</t>
<t tx="ekr.20240927163405.118">fn show_output_list (&amp;self) {
    println!("\nOutput tokens...");
    for (i, arg) in self.output_list.iter().enumerate() {
        if i &gt; 0 {
            print!("{:?}", arg);
        }
    }
}
</t>
<t tx="ekr.20240927163405.119">fn tokenize_contents(&amp;mut self, contents: String ) -&gt; u32 {

    let count = self.make_input_list(&amp;contents);
    self.make_output_list();
    return count;
}
</t>
<t tx="ekr.20240927163405.12">fn do_Int(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Int", tok_value);
}
</t>
<t tx="ekr.20240927163405.13">fn do_Name(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Name", tok_value);
}
</t>
<t tx="ekr.20240927163405.14">fn do_String(&amp;mut self, tok_value: &amp;str) {
    // correct.
    // print!("{tok_value}");
    
    // incorrect.
        // let quote = if *triple_quoted {"'''"} else {"'"};
        // print!("{:?}:{quote}{value}{quote}", kind);

    self.add_output_token("String", tok_value);
}
</t>
<t tx="ekr.20240927163405.15"></t>
<t tx="ekr.20240927163405.16">fn do_Dedent(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Dedent", tok_value);
}
</t>
<t tx="ekr.20240927163405.17">fn do_Indent(&amp;mut self, tok_value: &amp;str) {
    self.add_output_token("Indent", tok_value);
}
</t>
<t tx="ekr.20240927163405.18">fn do_Newline(&amp;mut self) {
    self.add_output_token("Indent", "\n");
}
</t>
<t tx="ekr.20240927163405.19">fn do_NonLogicalNewline(&amp;mut self) {
    self.add_output_token("Indent", "\n");
}
</t>
<t tx="ekr.20240927163405.2">// #[allow(dead_code)]
fn add_input_token (&amp;mut self, kind: &amp;str, value: &amp;str) {
    //! Add one token to the output list.
    // println!("{:?}", kind);
    self.input_list.push(InputTok {
        kind: kind.to_string(),
        value: value.to_string(),
    });
}
</t>
<t tx="ekr.20240927163405.20"></t>
<t tx="ekr.20240927163405.21">fn do_Amper(&amp;mut self) {
    self.add_output_token("Amper", "&amp;");
}
</t>
<t tx="ekr.20240927163405.22">fn do_AmperEqual(&amp;mut self) {
    self.add_output_token("AmperEqual", "&amp;=");
}
</t>
<t tx="ekr.20240927163405.23">fn do_And(&amp;mut self) {
    self.add_output_token("And", "and");
}
</t>
<t tx="ekr.20240927163405.24">fn do_As(&amp;mut self) {
    self.add_output_token("As", "as");
}
</t>
<t tx="ekr.20240927163405.25">fn do_Assert(&amp;mut self) {
    self.add_output_token("Assert", "assert");
}
</t>
<t tx="ekr.20240927163405.26">fn do_Async(&amp;mut self) {
    self.add_output_token("Async", "async");
}
</t>
<t tx="ekr.20240927163405.27">fn do_At(&amp;mut self) {
    self.add_output_token("At", "@");
}
</t>
<t tx="ekr.20240927163405.28">fn do_AtEqual(&amp;mut self) {
    self.add_output_token("AtEqual", "@=");
}
</t>
<t tx="ekr.20240927163405.29">fn do_Await(&amp;mut self) {
    self.add_output_token("Await", "await");
}
</t>
<t tx="ekr.20240927163405.3">fn add_output_token (&amp;mut self, kind: &amp;str, value: &amp;str) {
    //! Add one token to the output list.
    self.output_list.push(OutputTok {
        kind: kind.to_string(),
        value: value.to_string(),
    });
}
</t>
<t tx="ekr.20240927163405.30">fn do_Break(&amp;mut self) {
    self.add_output_token("Break", "break");
}
</t>
<t tx="ekr.20240927163405.31">fn do_Case(&amp;mut self) {
    self.add_output_token("Case", "case");
}
</t>
<t tx="ekr.20240927163405.32">fn do_CircumFlex(&amp;mut self) {
    self.add_output_token("CircumFlex", "^");
}
</t>
<t tx="ekr.20240927163405.33">fn do_CircumflexEqual(&amp;mut self) {
    self.add_output_token("CircumflexEqual", "^=");
}
</t>
<t tx="ekr.20240927163405.34">fn do_Class(&amp;mut self) {
    self.add_output_token("Class", "class");
}
</t>
<t tx="ekr.20240927163405.35">fn do_Colon(&amp;mut self) {
    self.add_output_token("Colon", ":");
}
</t>
<t tx="ekr.20240927163405.36">fn do_ColonEqual(&amp;mut self) {
    self.add_output_token("ColonEqual", ":=");
}
</t>
<t tx="ekr.20240927163405.37">fn do_Comma(&amp;mut self) {
    self.add_output_token("Comma", ",");
}
</t>
<t tx="ekr.20240927163405.38">fn do_Continue(&amp;mut self) {
    self.add_output_token("Continue", "continue");
}
</t>
<t tx="ekr.20240927163405.39">fn do_Def(&amp;mut self) {
    self.add_output_token("Def", "def");
}
</t>
<t tx="ekr.20240927163405.4">pub fn beautify_all_files(&amp;mut self) {
    println!("beautify_all_files");
    for file_name in self.files_list.clone() {
        self.beautify_one_file(file_name);
    }
}

</t>
<t tx="ekr.20240927163405.40">fn do_Del(&amp;mut self) {
    self.add_output_token("Del", "del");
}
</t>
<t tx="ekr.20240927163405.41">fn do_Dot(&amp;mut self) {
    self.add_output_token("Dot", ".");
}
</t>
<t tx="ekr.20240927163405.42">fn do_DoubleSlash(&amp;mut self) {
    self.add_output_token("DoubleSlash", "//");
}
</t>
<t tx="ekr.20240927163405.43">fn do_DoubleSlashEqual(&amp;mut self) {
    self.add_output_token("DoubleSlashEqual", "//=");
}
</t>
<t tx="ekr.20240927163405.44">fn do_DoubleStar(&amp;mut self) {
    self.add_output_token("DoubleStar", "**");
}
</t>
<t tx="ekr.20240927163405.45">fn do_DoubleStarEqual(&amp;mut self) {
    self.add_output_token("DoubleStarEqual", "**=");
}
</t>
<t tx="ekr.20240927163405.46">fn do_Elif(&amp;mut self) {
    self.add_output_token("Elif", "elif");
}
</t>
<t tx="ekr.20240927163405.47">fn do_Ellipsis(&amp;mut self) {
    self.add_output_token("Ellipsis", "...");
}
</t>
<t tx="ekr.20240927163405.48">fn do_Else(&amp;mut self) {
    self.add_output_token("Else", "else");
}
</t>
<t tx="ekr.20240927163405.49">fn do_EndOfFile(&amp;mut self) {
    self.add_output_token("EndOfFile", "EOF");
}
</t>
<t tx="ekr.20240927163405.5">fn beautify_one_file(&amp;mut self, file_name: String) {
    // println!("beautifiy_one_file: {file_name}");
    self.output_list = Vec::new();
    // Read the file into contents (a String).
    let t1 = std::time::Instant::now();
    let contents = fs::read_to_string(file_name.clone())
        .expect("Error reading{file_name}");
    // print_type(&amp;contents, "contents");
    let t2 = t1.elapsed();
    // Tokenize.
    let t3 = std::time::Instant::now();
    let n_tokens = self.tokenize_contents(contents);
    let t4 = t3.elapsed();
    // Report
    if self.enabled("--report") {
        println!(" file name: {file_name}");
        println!("      read: {:.2?}", t2);
        println!("  tokenize: {:.2?}", t4);
        println!("    tokens: {n_tokens}");
    }
    // Show tokens.
    &lt;&lt; show output_list &gt;&gt;
}
</t>
<t tx="ekr.20240927163405.50">fn do_EqEqual(&amp;mut self) {
    self.add_output_token("EqEqual", "==");
}
</t>
<t tx="ekr.20240927163405.51">fn do_Equal(&amp;mut self) {
    self.add_output_token("Equal", "=");
}
</t>
<t tx="ekr.20240927163405.52">fn do_Except(&amp;mut self) {
    self.add_output_token("Except", "except");
}
</t>
<t tx="ekr.20240927163405.53">fn do_False(&amp;mut self) {
    self.add_output_token("False", "False");
}
</t>
<t tx="ekr.20240927163405.54">fn do_Finally(&amp;mut self) {
    self.add_output_token("Finally", "finally");
}
</t>
<t tx="ekr.20240927163405.55">fn do_For(&amp;mut self) {
    self.add_output_token("For", "for");
}
</t>
<t tx="ekr.20240927163405.56">fn do_From(&amp;mut self) {
    self.add_output_token("From", "from");
}
</t>
<t tx="ekr.20240927163405.57">fn do_Global(&amp;mut self) {
    self.add_output_token("Global", "global");
}
</t>
<t tx="ekr.20240927163405.58">fn do_Greater(&amp;mut self) {
    self.add_output_token("Greater", "&gt;");
}
</t>
<t tx="ekr.20240927163405.59">fn do_GreaterEqual(&amp;mut self) {
    self.add_output_token("GreaterEqual", "&gt;-");
}
</t>
<t tx="ekr.20240927163405.6">if false {  // --show-output
    self.show_output_list()
}
</t>
<t tx="ekr.20240927163405.60">fn do_If(&amp;mut self) {
    self.add_output_token("If", "if");
}
</t>
<t tx="ekr.20240927163405.61">fn do_Import(&amp;mut self) {
    self.add_output_token("Import", "import");
}
</t>
<t tx="ekr.20240927163405.62">fn do_In(&amp;mut self) {
    self.add_output_token("In", "in");
}
</t>
<t tx="ekr.20240927163405.63">fn do_Is(&amp;mut self) {
    self.add_output_token("Is", "is");
}
</t>
<t tx="ekr.20240927163405.64">fn do_Lambda(&amp;mut self) {
    self.add_output_token("Lambda", "lambda");
}
</t>
<t tx="ekr.20240927163405.65">fn do_Lbrace(&amp;mut self) {
    self.add_output_token("Lbrace", "[");
}
</t>
<t tx="ekr.20240927163405.66">fn do_LeftShift(&amp;mut self) {
    self.add_output_token("LeftShift", "&lt;&lt;");
}
</t>
<t tx="ekr.20240927163405.67">fn do_LeftShiftEqual(&amp;mut self) {
    self.add_output_token("LeftShiftEqual", "&lt;&lt;=");
}
</t>
<t tx="ekr.20240927163405.68">fn do_Less(&amp;mut self) {
    self.add_output_token("Less", "&lt;");
}
</t>
<t tx="ekr.20240927163405.69">fn do_LessEqual(&amp;mut self) {
    self.add_output_token("LessEqual", "&lt;=");
}
</t>
<t tx="ekr.20240927163405.7"></t>
<t tx="ekr.20240927163405.70">fn do_Lpar(&amp;mut self) {
    self.add_output_token("Lpar", "(");
}
</t>
<t tx="ekr.20240927163405.71">fn do_Lsqb(&amp;mut self) {
    self.add_output_token("Lsqb", "[");
}
</t>
<t tx="ekr.20240927163405.72">fn do_Match(&amp;mut self) {
    self.add_output_token("Match", "match");
}
</t>
<t tx="ekr.20240927163405.73">fn do_Minus(&amp;mut self) {
    self.add_output_token("Minus", "-");
}
</t>
<t tx="ekr.20240927163405.74">fn do_MinusEqual(&amp;mut self) {
    self.add_output_token("MinusEqual", "-=");
}
</t>
<t tx="ekr.20240927163405.75">fn do_None(&amp;mut self) {
    self.add_output_token("None", "None");
}
</t>
<t tx="ekr.20240927163405.76">fn do_Nonlocal(&amp;mut self) {
    self.add_output_token("Nonlocal", "nonlocal");
}
</t>
<t tx="ekr.20240927163405.77">fn do_Not(&amp;mut self) {
    self.add_output_token("Not", "not");
}
</t>
<t tx="ekr.20240927163405.78">fn do_NotEqual(&amp;mut self) {
    self.add_output_token("NotEqual", "!=");
}
</t>
<t tx="ekr.20240927163405.79">fn do_Or(&amp;mut self) {
    self.add_output_token("Or", "or");
}
</t>
<t tx="ekr.20240927163405.8"></t>
<t tx="ekr.20240927163405.80">fn do_Pass(&amp;mut self) {
    self.add_output_token("Pass", "pass");
}
</t>
<t tx="ekr.20240927163405.81">fn do_Percent(&amp;mut self) {
    self.add_output_token("Percent", "%");
}
</t>
<t tx="ekr.20240927163405.82">fn do_PercentEqual(&amp;mut self) {
    self.add_output_token("PercentEqual", "%=");
}
</t>
<t tx="ekr.20240927163405.83">fn do_Plus(&amp;mut self) {
    self.add_output_token("Plus", "+");
}
</t>
<t tx="ekr.20240927163405.84">fn do_PlusEqual(&amp;mut self) {
    self.add_output_token("PlusEqual", "+=");
}
</t>
<t tx="ekr.20240927163405.85">fn do_Raise(&amp;mut self) {
    self.add_output_token("Raise", "raise");
}
</t>
<t tx="ekr.20240927163405.86">fn do_Rarrow(&amp;mut self) {
    self.add_output_token("Rarrow", "-&gt;");
}
</t>
<t tx="ekr.20240927163405.87">fn do_Rbrace(&amp;mut self) {
    self.add_output_token("Rbrace", "]");
}
</t>
<t tx="ekr.20240927163405.88">fn do_Return(&amp;mut self) {
    self.add_output_token("Return", "return");
}
</t>
<t tx="ekr.20240927163405.89">fn do_RightShift(&amp;mut self) {
    self.add_output_token("RightShift", "&gt;&gt;");
}
</t>
<t tx="ekr.20240927163405.9">fn do_Comment(&amp;mut self, tok_value: &amp;str) {
    // print!("{tok_value}");  // Correct.
    // print!("{value} ");  // Wrong!
    self.add_output_token("Comment", tok_value);
}
</t>
<t tx="ekr.20240927163405.90">fn do_RightShiftEqual(&amp;mut self) {
    self.add_output_token("RightShiftEqual", "&gt;&gt;=");
}
</t>
<t tx="ekr.20240927163405.91">fn do_Rpar(&amp;mut self) {
    self.add_output_token("Rpar", ")");
}
</t>
<t tx="ekr.20240927163405.92">fn do_Rsqb(&amp;mut self) {
    self.add_output_token("Rsqb", "]");
}
</t>
<t tx="ekr.20240927163405.93">fn do_Semi(&amp;mut self) {
    self.add_output_token("Semi", ";");
}
</t>
<t tx="ekr.20240927163405.94">fn do_Slash(&amp;mut self) {
    self.add_output_token("Slash", "/");
}
</t>
<t tx="ekr.20240927163405.95">fn do_SlashEqual(&amp;mut self) {
    self.add_output_token("SlashEqual", "/=");
}
</t>
<t tx="ekr.20240927163405.96">fn do_Star(&amp;mut self) {
    self.add_output_token("Star", "*");
}
</t>
<t tx="ekr.20240927163405.97">fn do_StarEqual(&amp;mut self) {
    self.add_output_token("StarEqual", "*=");
}
</t>
<t tx="ekr.20240927163405.98">fn do_StartExpression(&amp;mut self) {
    // self.add_output_token("StartExpression", "");
}
</t>
<t tx="ekr.20240927163405.99">fn do_StartInteractive(&amp;mut self) {
    // self.add_output_token("StartModule", "");
}
</t>
<t tx="ekr.20240927163812.1"></t>
<t tx="ekr.20240927163855.1">@language python

g.cls()
print('@command test')
import os
if c.isChanged():
    c.save()
root = r'C:\Repos\ekr-private\rust_beautifier'
os.chdir(root)
for command in (
    'cargo run -- --all --report --write c:/Repos/leo-editor/leo/core/leoTokens.py',
):
    print(command)
    os.system(command)
</t>
<t tx="ekr.20240927163907.1">@language rest
@wrap

The Rust version of Leo's beautifier *must* generate pseudo 'ws' tokens, just as in leoTokens.py because 'ws' tokens are needed to support the @nobeautify directive.

Stats:

 file name: c:/Repos/leo-editor/leo/core/leoTokens.py
      read: 484.20s
  tokenize: 11.9ms to 12.4ms
    tokens: 9739</t>
<t tx="ekr.20240927163942.1">//! leoTokens.rs: A beautifier for Python that uses *only* tokens.

&lt;&lt; leoTokens.rs: global suppressions &gt;&gt;
&lt;&lt; leoTokens.rs: use statements &gt;&gt;

@others

@language rust
@tabwidth -4
@pagewidth 70
</t>
<t tx="ekr.20240927163942.10">if false {  // --show-output
    self.show_output_list()
}
</t>
<t tx="ekr.20240927163942.100">fn do_Star(&amp;mut self) {
    self.add_output_string("Star", "*");
}
</t>
<t tx="ekr.20240927163942.101">fn do_StarEqual(&amp;mut self) {
    self.add_output_string("StarEqual", "*=");
}
</t>
<t tx="ekr.20240927163942.102">fn do_StartExpression(&amp;mut self) {
    // self.add_output_string("StartExpression", "");
}
</t>
<t tx="ekr.20240927163942.103">fn do_StartInteractive(&amp;mut self) {
    // self.add_output_string("StartModule", "");
}
</t>
<t tx="ekr.20240927163942.104">fn do_StartModule(&amp;mut self) {
    // self.add_output_string("StartModule", "");
    println!("do_StartModule");
}
</t>
<t tx="ekr.20240927163942.105">fn do_Tilde(&amp;mut self) {
    self.add_output_string("Tilde", "~");
}
</t>
<t tx="ekr.20240927163942.106">fn do_True(&amp;mut self) {
    self.add_output_string("True", "True");
}
</t>
<t tx="ekr.20240927163942.107">fn do_Try(&amp;mut self) {
    self.add_output_string("Try", "try");
}
</t>
<t tx="ekr.20240927163942.108">fn do_Type(&amp;mut self) {
    self.add_output_string("Type", "type");
}
</t>
<t tx="ekr.20240927163942.109">fn do_Vbar(&amp;mut self) {
    self.add_output_string("Vbar", "|");
}
</t>
<t tx="ekr.20240927163942.11"></t>
<t tx="ekr.20240927163942.110">fn do_VbarEqual(&amp;mut self) {
    self.add_output_string("VbarEqual", "|=");
}
</t>
<t tx="ekr.20240927163942.111">fn do_While(&amp;mut self) {
    self.add_output_string("While", "while");
}
</t>
<t tx="ekr.20240927163942.112">fn do_With(&amp;mut self) {
    self.add_output_string("With", "with");
}
</t>
<t tx="ekr.20240927163942.113">fn do_Yield(&amp;mut self) {
    self.add_output_string("Yield", "yield");
}
</t>
<t tx="ekr.20240927163942.114">fn enabled(&amp;self, arg: &amp;str) -&gt; bool {
    //! Beautifier::enabled: return true if the given command-line argument is enabled.
    //! Example:  x.enabled("--report");
    return self.args.contains(&amp;arg.to_string());

}
</t>
<t tx="ekr.20240927163942.115">fn get_args(&amp;mut self) {
    //! Beautifier::get_args: Set the args and files_list ivars.
    let args: Vec&lt;String&gt; = env::args().collect();
    let valid_args = vec![
        "--all", 
        "--beautified",
        "--diff",
        "-h", "--help",
        "--report",
        "--write",
    ];
    for (i, arg) in args.iter().enumerate() {
        if i &gt; 0 {
            if valid_args.contains(&amp;arg.as_str()) {
                self.args.push(arg.to_string())
            }
            else if 
                arg.as_str().starts_with("--") ||
                arg.as_str().starts_with("--")
            {
                println!("Ignoring invalid arg: {arg}");
            }
            else {
                println!("File: {arg}");
                self.files_list.push(arg.to_string());
            }
        }
    }
}
</t>
<t tx="ekr.20240927163942.116">fn make_input_list(&amp;mut self, contents: &amp;str) -&gt; u32 {

    let mut count: u32 = 0;
    let results = lex(&amp;contents, Mode::Module);  // An iterator yielding Option(Tok).
    for result in results {
        use Tok::*;
        count += 1;
        let token = result.ok().unwrap();
        let (ref tok_class, tok_range) = token;
        let tok_value = &amp;contents[tok_range];

        // Variants names are necessary, but otherwise not used.
        #[allow(unused_variables)]
        let class_name = match tok_class {
            // Tokens with values...
            // Use tok_value for *all* values.
            Comment(value) =&gt; "Comment",  // No idea why parens are needed here.
            Complex { real, imag } =&gt; "Complex",
            Float { value } =&gt; "Float",
            Int { value } =&gt; "Int",
            Name { name } =&gt; "Name",
            Tok::String { value, kind, triple_quoted } =&gt; "String",
            
            // Common tokens...
            Class =&gt; "Class",
            Dedent =&gt; "Dedent",
            Def =&gt; "Def",
            Indent =&gt; "Indent",
            Newline =&gt; "Newline",
            NonLogicalNewline =&gt; "NonLogicalNewline",

            // All other tokens...
            Amper =&gt; "Amper",
            AmperEqual =&gt; "AmperEqual",
            And =&gt; "And",
            As =&gt; "As",
            Assert =&gt; "Assert",
            Async =&gt; "Async",
            At =&gt; "At",
            AtEqual =&gt; "AtEqual",
            Await =&gt; "Await",
            Break =&gt; "Break",
            Case =&gt; "Case",
            CircumFlex =&gt; "CircumFlex",
            CircumflexEqual =&gt; "CircumflexEqual",
            Colon =&gt; "Colon",
            ColonEqual =&gt; "ColonEqual",
            Comma =&gt; "Comma",
            Continue =&gt; "Continue",
            Del =&gt; "Del",
            Dot =&gt; "Dot",
            DoubleSlash =&gt; "DoubleSlash",
            DoubleSlashEqual =&gt; "DoubleSlashEqual",
            DoubleStar =&gt; "DoubleStar",
            DoubleStarEqual =&gt; "DoubleStarEqual",
            Elif =&gt; "Elif",
            Ellipsis =&gt; "Ellipsis",
            Else =&gt; "Else",
            EndOfFile =&gt; "EndOfFile",
            EqEqual =&gt; "EqEqual",
            Equal =&gt; "Equal",
            Except =&gt; "Except",
            False =&gt; "False",
            Finally =&gt; "Finally",
            For =&gt; "For",
            From =&gt; "From",
            Global =&gt; "Global",
            Greater =&gt; "Greater",
            GreaterEqual =&gt; "GreaterEqual",
            If =&gt; "If",
            Import =&gt; "Import",
            In =&gt; "In",
            Is =&gt; "Is",
            Lambda =&gt; "Lambda",
            Lbrace =&gt; "Lbrace",
            LeftShift =&gt; "LeftShift",
            LeftShiftEqual =&gt; "LeftShiftEqual",
            Less =&gt; "Less",
            LessEqual =&gt; "LessEqual",
            Lpar =&gt; "Lpar",
            Lsqb =&gt; "Lsqb",
            Match =&gt; "Match",
            Minus =&gt; "Minus",
            MinusEqual =&gt; "MinusEqual",
            None =&gt; "None",
            Nonlocal =&gt; "Nonlocal",
            Not =&gt; "Not",
            NotEqual =&gt; "NotEqual",
            Or =&gt; "Or",
            Pass =&gt; "Pass",
            Percent =&gt; "Percent",
            PercentEqual =&gt; "PercentEqual",
            Plus =&gt; "Plus",
            PlusEqual =&gt; "PlusEqual",
            Raise =&gt; "Raise",
            Rarrow =&gt; "Rarrow",
            Rbrace =&gt; "Rbrace",
            Return =&gt; "Return",
            RightShift =&gt; "RightShift",
            RightShiftEqual =&gt; "RightShiftEqual",
            Rpar =&gt; "Rpar",
            Rsqb =&gt; "Rsqb",
            Semi =&gt; "Semi",
            Slash =&gt; "Slash",
            SlashEqual =&gt; "SlashEqual",
            Star =&gt; "Star",
            StarEqual =&gt; "StarEqual",
            StartExpression =&gt; "StartExpression",
            StartInteractive =&gt; "StartInteractive",
            StartModule =&gt; "StartModule",
            Tilde =&gt; "Tilde",
            True =&gt; "True",
            Try =&gt; "Try",
            Type =&gt; "Type",
            Vbar =&gt; "Vbar",
            VbarEqual =&gt; "VbarEqual",
            While =&gt; "While",
            With =&gt; "With",
            Yield =&gt; "Yield",
        };
        self.add_input_token(class_name, tok_value);
    }
    return count;
}
</t>
<t tx="ekr.20240927163942.117">fn make_output_list(&amp;mut self) {

    //// Prototype only.
    for input_token in &amp;self.input_list.clone() {
        // println!("{:?}", input_token);
        self.add_output_string(input_token.kind.as_str(), input_token.value.as_str());
    }
}
</t>
<t tx="ekr.20240927163942.118">pub fn new() -&gt; Beautifier {
    let mut x = Beautifier {
        args: Vec::new(),
        files_list: Vec::new(),
        input_list: Vec::new(),
        output_list: Vec::new(),
    };
    x.get_args();
    return x;
}
</t>
<t tx="ekr.20240927163942.119">fn show_args (&amp;self) {
    println!("Command-line arguments...");
    for (i, arg) in self.args.iter().enumerate() {
        if i &gt; 0 {
            println!("  {arg}");
        }
    }
    for file_arg in self.files_list.iter() {
        println!("  {file_arg}");
    }
}
</t>
<t tx="ekr.20240927163942.12"></t>
<t tx="ekr.20240927163942.120">fn show_help (&amp;self) {
    //! Beautifier::show_help: print the help messages.
    println!("{}", textwrap::dedent("
        Beautify or diff files.

        -h --help:      Print this help message and exit.
        --all:          Beautify all files, even unchanged files.
        --beautified:   Report beautified files individually, even if not written.
        --diff:         Show diffs instead of changing files.
        --report:       Print summary report.
        --write:        Write beautifed files (dry-run mode otherwise).
    "));
}
</t>
<t tx="ekr.20240927163942.121">fn show_output_list (&amp;self) {
    println!("\nOutput list...");
    for (i, arg) in self.output_list.iter().enumerate() {
        if i &gt; 0 {
            print!("{:?}", arg);
        }
    }
}
</t>
<t tx="ekr.20240927163942.122">fn tokenize_contents(&amp;mut self, contents: String ) -&gt; u32 {

    let count = self.make_input_list(&amp;contents);
    
    // Simulate iterating the input list twice.
    for _z in &amp;self.input_list.clone() {
    }
    for _z in &amp;self.input_list.clone() {
    }

    // Simulate writing strings to the output list.
    // self.make_output_list();
    for _z in &amp;self.input_list.clone() {
    }
    return count;
}
</t>
<t tx="ekr.20240927163942.123">// Only Clone is valid for String.
#[derive(Clone)]
struct InputTok {
    kind: String,
    value: String,
}

impl fmt::Debug for InputTok {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        let kind_s = format!("{:?}", self.kind);
        let mut value = self.value.to_string();
        if true {
            return write!(f, "{value} ");
        }
        else {  // Debug format.
            value.truncate(60);
            // repr format is not useful.
            // let value_s = format!("{:?}", value);
            let value_s = format!("{}", value);
            return write!(f, "InputTok: {kind_s:&gt;10}: {value_s}");
        }
    }
}
</t>
<t tx="ekr.20240927163942.124">pub fn entry() {

    if false {
        tokenize();
        return;
    }
    // Main line of beautifier.
    let mut x = Beautifier::new();
    if x.enabled("--help") || x.enabled("-h") {
        x.show_help();
        return;
    }
    x.show_args();
    x.beautify_all_files();
}
</t>
<t tx="ekr.20240927163942.125">fn tokenize() {
    &lt;&lt; tokenize: define contents &gt;&gt;
    println!("fn tokenize");
    println!("\nSource:\n{contents}");

    for debug in [true, false].iter() {

        println!("{}", if *debug {"Tokens..."} else {"\nBeautified:"});

        let results = lex(contents, Mode::Module);  // An iterator yielding Option(Tok).
        let mut count = 0;
        let mut lws = String::new();
        for (i, result) in results.enumerate() {
            use Tok::*;
            let token = result.ok().unwrap();
            let (ref tok_class, tok_range) = token;
            let tok_value = &amp;contents[tok_range];

            if *debug {
                let s = format!("{tok_class}");
                print!("\nToken: {s:20} {:?}", tok_value);
            }
            else {
                // Comment(value), Name(name)
                #[allow(unused_variables)]
                match tok_class {
                    Comment(value) =&gt; {
                        // print!("{value} ");  // Wrong!
                        print!("{tok_value}");
                    },
                    Dedent =&gt; {
                        lws.pop();
                        lws.pop();
                        print!("{lws}");
                    },
                    Def =&gt; {
                        print!("{tok_value} ");
                    },
                    Indent =&gt; {
                        lws.push_str("    ");
                        print!("{lws}");
                    },
                    Name {name} =&gt; {
                        print!("{tok_value} ");
                    },
                    Newline =&gt; {
                        print!("{tok_value}");
                        print!("{lws}");
                        if false {  // old
                            println!("");
                            print!("{lws}");
                        }
                    },
                    NonLogicalNewline =&gt; {
                        println!("");
                        print!("{lws}");
                    },
                    Return =&gt; {
                        print!("{tok_value} ");
                    },
                    Tok::String {value, kind, triple_quoted} =&gt; {
                        // correct.
                        print!("{tok_value}");
                        if false {  // incorrect.
                            let quote = if *triple_quoted {"'''"} else {"'"};
                            print!("{:?}:{quote}{value}{quote}", kind);
                        }
                    },
                    _ =&gt; {
                        print!("{tok_value}");
                        if false {
                            // to_string quotes values!
                            let s = tok_class.to_string().replace("'", "");
                            print!("{s}");
                        }
                    },
                }
            }
            count = i
        }
        if *debug {
            println!("\n{count} tokens")
        }
    }
}
</t>
<t tx="ekr.20240927163942.126">let contents = r#"
def test():
# Comment 1.
print('abc')
# Comment 2.
"#;

// print("xyz")
// print(rf'pdb')
// print(fr'pdb2')
// return bool(i &amp; 1)
</t>
<t tx="ekr.20240927163942.127">#[allow(dead_code)]
fn print_type&lt;T&gt;(_: &amp;T, tag: &amp;str) {
    println!("{tag} type: {}", std::any::type_name::&lt;T&gt;())
}
</t>
<t tx="ekr.20240927163942.13">fn do_Comment(&amp;mut self, tok_value: &amp;str) {
    // print!("{tok_value}");  // Correct.
    // print!("{value} ");  // Wrong!
    self.add_output_string("Comment", tok_value);
}
</t>
<t tx="ekr.20240927163942.14">fn do_Complex(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Complex", tok_value);
}
</t>
<t tx="ekr.20240927163942.15">fn do_Float(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Float", tok_value);
}
</t>
<t tx="ekr.20240927163942.16">fn do_Int(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Int", tok_value);
}
</t>
<t tx="ekr.20240927163942.17">fn do_Name(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Name", tok_value);
}
</t>
<t tx="ekr.20240927163942.18">fn do_String(&amp;mut self, tok_value: &amp;str) {
    // correct.
    // print!("{tok_value}");
    
    // incorrect.
        // let quote = if *triple_quoted {"'''"} else {"'"};
        // print!("{:?}:{quote}{value}{quote}", kind);

    self.add_output_string("String", tok_value);
}
</t>
<t tx="ekr.20240927163942.19"></t>
<t tx="ekr.20240927163942.2">// All suppressions are local to a class or statement.

// #![allow(non_snake_case)]
// #![allow(unused_imports)]
// #![allow(unreachable_code)]
// #![allow(unused_mut)]
// #![allow(unused_variables)]
</t>
<t tx="ekr.20240927163942.20">fn do_Dedent(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Dedent", tok_value);
}
</t>
<t tx="ekr.20240927163942.21">fn do_Indent(&amp;mut self, tok_value: &amp;str) {
    self.add_output_string("Indent", tok_value);
}
</t>
<t tx="ekr.20240927163942.22">fn do_Newline(&amp;mut self) {
    self.add_output_string("Indent", "\n");
}
</t>
<t tx="ekr.20240927163942.23">fn do_NonLogicalNewline(&amp;mut self) {
    self.add_output_string("Indent", "\n");
}
</t>
<t tx="ekr.20240927163942.24"></t>
<t tx="ekr.20240927163942.25">fn do_Amper(&amp;mut self) {
    self.add_output_string("Amper", "&amp;");
}
</t>
<t tx="ekr.20240927163942.26">fn do_AmperEqual(&amp;mut self) {
    self.add_output_string("AmperEqual", "&amp;=");
}
</t>
<t tx="ekr.20240927163942.27">fn do_And(&amp;mut self) {
    self.add_output_string("And", "and");
}
</t>
<t tx="ekr.20240927163942.28">fn do_As(&amp;mut self) {
    self.add_output_string("As", "as");
}
</t>
<t tx="ekr.20240927163942.29">fn do_Assert(&amp;mut self) {
    self.add_output_string("Assert", "assert");
}
</t>
<t tx="ekr.20240927163942.3">use rustpython_parser::{lexer::lex, Mode, Tok};

use std::env;
use std::fs;
use std::fmt;
// use std::time;

use textwrap;
</t>
<t tx="ekr.20240927163942.30">fn do_Async(&amp;mut self) {
    self.add_output_string("Async", "async");
}
</t>
<t tx="ekr.20240927163942.31">fn do_At(&amp;mut self) {
    self.add_output_string("At", "@");
}
</t>
<t tx="ekr.20240927163942.32">fn do_AtEqual(&amp;mut self) {
    self.add_output_string("AtEqual", "@=");
}
</t>
<t tx="ekr.20240927163942.33">fn do_Await(&amp;mut self) {
    self.add_output_string("Await", "await");
}
</t>
<t tx="ekr.20240927163942.34">fn do_Break(&amp;mut self) {
    self.add_output_string("Break", "break");
}
</t>
<t tx="ekr.20240927163942.35">fn do_Case(&amp;mut self) {
    self.add_output_string("Case", "case");
}
</t>
<t tx="ekr.20240927163942.36">fn do_CircumFlex(&amp;mut self) {
    self.add_output_string("CircumFlex", "^");
}
</t>
<t tx="ekr.20240927163942.37">fn do_CircumflexEqual(&amp;mut self) {
    self.add_output_string("CircumflexEqual", "^=");
}
</t>
<t tx="ekr.20240927163942.38">fn do_Class(&amp;mut self) {
    self.add_output_string("Class", "class");
}
</t>
<t tx="ekr.20240927163942.39">fn do_Colon(&amp;mut self) {
    self.add_output_string("Colon", ":");
}
</t>
<t tx="ekr.20240927163942.4"></t>
<t tx="ekr.20240927163942.40">fn do_ColonEqual(&amp;mut self) {
    self.add_output_string("ColonEqual", ":=");
}
</t>
<t tx="ekr.20240927163942.41">fn do_Comma(&amp;mut self) {
    self.add_output_string("Comma", ",");
}
</t>
<t tx="ekr.20240927163942.42">fn do_Continue(&amp;mut self) {
    self.add_output_string("Continue", "continue");
}
</t>
<t tx="ekr.20240927163942.43">fn do_Def(&amp;mut self) {
    self.add_output_string("Def", "def");
}
</t>
<t tx="ekr.20240927163942.44">fn do_Del(&amp;mut self) {
    self.add_output_string("Del", "del");
}
</t>
<t tx="ekr.20240927163942.45">fn do_Dot(&amp;mut self) {
    self.add_output_string("Dot", ".");
}
</t>
<t tx="ekr.20240927163942.46">fn do_DoubleSlash(&amp;mut self) {
    self.add_output_string("DoubleSlash", "//");
}
</t>
<t tx="ekr.20240927163942.47">fn do_DoubleSlashEqual(&amp;mut self) {
    self.add_output_string("DoubleSlashEqual", "//=");
}
</t>
<t tx="ekr.20240927163942.48">fn do_DoubleStar(&amp;mut self) {
    self.add_output_string("DoubleStar", "**");
}
</t>
<t tx="ekr.20240927163942.49">fn do_DoubleStarEqual(&amp;mut self) {
    self.add_output_string("DoubleStarEqual", "**=");
}
</t>
<t tx="ekr.20240927163942.5">#[derive(Debug)]
pub struct Beautifier {
    args: Vec&lt;String&gt;,
    files_list: Vec&lt;String&gt;,
    input_list: Vec&lt;InputTok&gt;,
    output_list: Vec&lt;String&gt;,
}

///// Temporary.
#[allow(dead_code)]
#[allow(non_snake_case)]
impl Beautifier {
    @others
}
</t>
<t tx="ekr.20240927163942.50">fn do_Elif(&amp;mut self) {
    self.add_output_string("Elif", "elif");
}
</t>
<t tx="ekr.20240927163942.51">fn do_Ellipsis(&amp;mut self) {
    self.add_output_string("Ellipsis", "...");
}
</t>
<t tx="ekr.20240927163942.52">fn do_Else(&amp;mut self) {
    self.add_output_string("Else", "else");
}
</t>
<t tx="ekr.20240927163942.53">fn do_EndOfFile(&amp;mut self) {
    self.add_output_string("EndOfFile", "EOF");
}
</t>
<t tx="ekr.20240927163942.54">fn do_EqEqual(&amp;mut self) {
    self.add_output_string("EqEqual", "==");
}
</t>
<t tx="ekr.20240927163942.55">fn do_Equal(&amp;mut self) {
    self.add_output_string("Equal", "=");
}
</t>
<t tx="ekr.20240927163942.56">fn do_Except(&amp;mut self) {
    self.add_output_string("Except", "except");
}
</t>
<t tx="ekr.20240927163942.57">fn do_False(&amp;mut self) {
    self.add_output_string("False", "False");
}
</t>
<t tx="ekr.20240927163942.58">fn do_Finally(&amp;mut self) {
    self.add_output_string("Finally", "finally");
}
</t>
<t tx="ekr.20240927163942.59">fn do_For(&amp;mut self) {
    self.add_output_string("For", "for");
}
</t>
<t tx="ekr.20240927163942.6">#[allow(unused_variables)]
fn add_output_string (&amp;mut self, kind: &amp;str, value: &amp;str) {
    //! Add one string to the output list.
    self.output_list.push(value.to_string())
}
</t>
<t tx="ekr.20240927163942.60">fn do_From(&amp;mut self) {
    self.add_output_string("From", "from");
}
</t>
<t tx="ekr.20240927163942.61">fn do_Global(&amp;mut self) {
    self.add_output_string("Global", "global");
}
</t>
<t tx="ekr.20240927163942.62">fn do_Greater(&amp;mut self) {
    self.add_output_string("Greater", "&gt;");
}
</t>
<t tx="ekr.20240927163942.63">fn do_GreaterEqual(&amp;mut self) {
    self.add_output_string("GreaterEqual", "&gt;-");
}
</t>
<t tx="ekr.20240927163942.64">fn do_If(&amp;mut self) {
    self.add_output_string("If", "if");
}
</t>
<t tx="ekr.20240927163942.65">fn do_Import(&amp;mut self) {
    self.add_output_string("Import", "import");
}
</t>
<t tx="ekr.20240927163942.66">fn do_In(&amp;mut self) {
    self.add_output_string("In", "in");
}
</t>
<t tx="ekr.20240927163942.67">fn do_Is(&amp;mut self) {
    self.add_output_string("Is", "is");
}
</t>
<t tx="ekr.20240927163942.68">fn do_Lambda(&amp;mut self) {
    self.add_output_string("Lambda", "lambda");
}
</t>
<t tx="ekr.20240927163942.69">fn do_Lbrace(&amp;mut self) {
    self.add_output_string("Lbrace", "[");
}
</t>
<t tx="ekr.20240927163942.7">// #[allow(dead_code)]
fn add_input_token (&amp;mut self, kind: &amp;str, value: &amp;str) {
    //! Add one token to the output list.
    // println!("{:?}", kind);
    self.input_list.push(InputTok {
        kind: kind.to_string(),
        value: value.to_string(),
    });
}
</t>
<t tx="ekr.20240927163942.70">fn do_LeftShift(&amp;mut self) {
    self.add_output_string("LeftShift", "&lt;&lt;");
}
</t>
<t tx="ekr.20240927163942.71">fn do_LeftShiftEqual(&amp;mut self) {
    self.add_output_string("LeftShiftEqual", "&lt;&lt;=");
}
</t>
<t tx="ekr.20240927163942.72">fn do_Less(&amp;mut self) {
    self.add_output_string("Less", "&lt;");
}
</t>
<t tx="ekr.20240927163942.73">fn do_LessEqual(&amp;mut self) {
    self.add_output_string("LessEqual", "&lt;=");
}
</t>
<t tx="ekr.20240927163942.74">fn do_Lpar(&amp;mut self) {
    self.add_output_string("Lpar", "(");
}
</t>
<t tx="ekr.20240927163942.75">fn do_Lsqb(&amp;mut self) {
    self.add_output_string("Lsqb", "[");
}
</t>
<t tx="ekr.20240927163942.76">fn do_Match(&amp;mut self) {
    self.add_output_string("Match", "match");
}
</t>
<t tx="ekr.20240927163942.77">fn do_Minus(&amp;mut self) {
    self.add_output_string("Minus", "-");
}
</t>
<t tx="ekr.20240927163942.78">fn do_MinusEqual(&amp;mut self) {
    self.add_output_string("MinusEqual", "-=");
}
</t>
<t tx="ekr.20240927163942.79">fn do_None(&amp;mut self) {
    self.add_output_string("None", "None");
}
</t>
<t tx="ekr.20240927163942.8">pub fn beautify_all_files(&amp;mut self) {
    for file_name in self.files_list.clone() {
        self.beautify_one_file(file_name);
    }
}

</t>
<t tx="ekr.20240927163942.80">fn do_Nonlocal(&amp;mut self) {
    self.add_output_string("Nonlocal", "nonlocal");
}
</t>
<t tx="ekr.20240927163942.81">fn do_Not(&amp;mut self) {
    self.add_output_string("Not", "not");
}
</t>
<t tx="ekr.20240927163942.82">fn do_NotEqual(&amp;mut self) {
    self.add_output_string("NotEqual", "!=");
}
</t>
<t tx="ekr.20240927163942.83">fn do_Or(&amp;mut self) {
    self.add_output_string("Or", "or");
}
</t>
<t tx="ekr.20240927163942.84">fn do_Pass(&amp;mut self) {
    self.add_output_string("Pass", "pass");
}
</t>
<t tx="ekr.20240927163942.85">fn do_Percent(&amp;mut self) {
    self.add_output_string("Percent", "%");
}
</t>
<t tx="ekr.20240927163942.86">fn do_PercentEqual(&amp;mut self) {
    self.add_output_string("PercentEqual", "%=");
}
</t>
<t tx="ekr.20240927163942.87">fn do_Plus(&amp;mut self) {
    self.add_output_string("Plus", "+");
}
</t>
<t tx="ekr.20240927163942.88">fn do_PlusEqual(&amp;mut self) {
    self.add_output_string("PlusEqual", "+=");
}
</t>
<t tx="ekr.20240927163942.89">fn do_Raise(&amp;mut self) {
    self.add_output_string("Raise", "raise");
}
</t>
<t tx="ekr.20240927163942.9">fn beautify_one_file(&amp;mut self, file_name: String) {
    // println!("beautifiy_one_file: {file_name}");
    self.output_list = Vec::new();
    // Read the file into contents (a String).
    let t1 = std::time::Instant::now();
    let contents = fs::read_to_string(file_name.clone())
        .expect("Error reading{file_name}");
    // print_type(&amp;contents, "contents");
    let t2 = t1.elapsed();
    // Tokenize.
    let t3 = std::time::Instant::now();
    let n_tokens = self.tokenize_contents(contents);
    let t4 = t3.elapsed();
    // Report
    if self.enabled("--report") {
        println!(" file name: {file_name}");
        println!("      read: {:.2?}", t2);
        println!("  tokenize: {:.2?}", t4);
        println!("    tokens: {n_tokens}");
    }
    // Show tokens.
    &lt;&lt; show output_list &gt;&gt;
}
</t>
<t tx="ekr.20240927163942.90">fn do_Rarrow(&amp;mut self) {
    self.add_output_string("Rarrow", "-&gt;");
}
</t>
<t tx="ekr.20240927163942.91">fn do_Rbrace(&amp;mut self) {
    self.add_output_string("Rbrace", "]");
}
</t>
<t tx="ekr.20240927163942.92">fn do_Return(&amp;mut self) {
    self.add_output_string("Return", "return");
}
</t>
<t tx="ekr.20240927163942.93">fn do_RightShift(&amp;mut self) {
    self.add_output_string("RightShift", "&gt;&gt;");
}
</t>
<t tx="ekr.20240927163942.94">fn do_RightShiftEqual(&amp;mut self) {
    self.add_output_string("RightShiftEqual", "&gt;&gt;=");
}
</t>
<t tx="ekr.20240927163942.95">fn do_Rpar(&amp;mut self) {
    self.add_output_string("Rpar", ")");
}
</t>
<t tx="ekr.20240927163942.96">fn do_Rsqb(&amp;mut self) {
    self.add_output_string("Rsqb", "]");
}
</t>
<t tx="ekr.20240927163942.97">fn do_Semi(&amp;mut self) {
    self.add_output_string("Semi", ";");
}
</t>
<t tx="ekr.20240927163942.98">fn do_Slash(&amp;mut self) {
    self.add_output_string("Slash", "/");
}
</t>
<t tx="ekr.20240927163942.99">fn do_SlashEqual(&amp;mut self) {
    self.add_output_string("SlashEqual", "/=");
}
</t>
<t tx="ekr.20240927164013.1"></t>
<t tx="ekr.20240928073118.1">@language python
g.cls()
import os
import subprocess

if c.changed:
    c.save()

command = 'cargo fmt'
subprocess.Popen(command, shell=True).communicate()
</t>
<t tx="ekr.20240928162805.1">@ignore
@nosearch
HEAD=ce3ef7a</t>
<t tx="ekr.20240928162805.10">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -272,7 +272,6 @@
 &lt;v t="ekr.20240927163812.1"&gt;&lt;vh&gt;from leo-editor-contrib rust_beautifier.leo&lt;/vh&gt;
 &lt;v t="ekr.20240927163855.1"&gt;&lt;vh&gt;@command test&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927163907.1"&gt;&lt;vh&gt;Read Me&lt;/vh&gt;&lt;/v&gt;
-&lt;v t="ekr.20240927163920.1"&gt;&lt;vh&gt;## @file src/main.rs&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927163942.1"&gt;&lt;vh&gt;## @file src/leotokens.rs&lt;/vh&gt;
 &lt;v t="ekr.20240927163942.2"&gt;&lt;vh&gt;&amp;lt;&amp;lt; leoTokens.rs: global suppressions &amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927163942.3"&gt;&lt;vh&gt;&amp;lt;&amp;lt; leoTokens.rs: use statements &amp;gt;&amp;gt;&lt;/vh&gt;&lt;/v&gt;
@@ -415,10 +414,12 @@
 &lt;v t="ekr.20240927154009.1"&gt;&lt;vh&gt;Files&lt;/vh&gt;
 &lt;v t="ekr.20240927151245.1"&gt;&lt;vh&gt;@edit Cargo.toml&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927151332.1"&gt;&lt;vh&gt;@file src/main.rs&lt;/vh&gt;&lt;/v&gt;
+&lt;v t="ekr.20240928161210.1"&gt;&lt;vh&gt;@file src/tbo.rs&lt;/vh&gt;&lt;/v&gt;
 &lt;/v&gt;
 &lt;v t="ekr.20240927154016.1"&gt;&lt;vh&gt;Notes&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927154323.1"&gt;&lt;vh&gt;** To do&lt;/vh&gt;&lt;/v&gt;
 &lt;v t="ekr.20240927151332.1"&gt;&lt;/v&gt;
+&lt;v t="ekr.20240928161210.1"&gt;&lt;/v&gt;
 &lt;/vnodes&gt;
 &lt;tnodes&gt;
 &lt;t tx="ekr.20240927151701.1"&gt;&lt;/t&gt;
@@ -1790,15 +1791,6 @@
       read: 484.20s
   tokenize: 11.9ms to 12.4ms
     tokens: 9739&lt;/t&gt;
-&lt;t tx="ekr.20240927163920.1"&gt;mod leotokens;
-
-fn main() {
-    leotokens::entry();
-}
-
-@language rust
-@tabwidth -4
-&lt;/t&gt;
 &lt;t tx="ekr.20240927163942.1"&gt;//! leoTokens.rs: A beautifier for Python that uses *only* tokens.
 
 &amp;lt;&amp;lt; leoTokens.rs: global suppressions &amp;gt;&amp;gt;
@language python
</t>
<t tx="ekr.20240928162805.2">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -1,55 +1,14 @@
 //@+leo-ver=5-thin
 //@+node:ekr.20240927151332.1: * @file src/main.rs
 //@@language rust
-// test_lexer.main.rs
-
-// From https://docs.rs/rustpython-parser/0.3.1/rustpython_parser/lexer/index.html
-
-// Must be first.
-// #![allow(unused_imports)]
-#![allow(unused_variables)]
-
-extern crate rustpython_parser;
-use rustpython_parser::{lexer::lex, Mode};
-use std::fs;
-use std::time::Instant; // Tok, StringKind
+// main.rs
 
 #[macro_use]
 extern crate fstrings;
 
+mod tbo;
+
 fn main() {
-    println!("");
-    let t1 = Instant::now();
-    // let source = "x    =      'RustPython'";
-    let file_path = "C:\\Repos\\leo-editor\\leo\\core\\leoApp.py";
-    let short_file_name = "leoApp.py";
-    let contents = fs::read_to_string(file_path).expect("Can not read file");
-
-    // let tokens = lex(contents, Mode::Module)
-    let tokens = lex(&amp;contents, Mode::Module)
-        .map(|tok| tok.expect("Failed to lex"))
-        .collect::&lt;Vec&lt;_&gt;&gt;();
-
-    // :? is debugging format.
-    let mut n_tokens: usize = 0;
-    for (token, range) in tokens {
-        // Range is a TextRange.
-        n_tokens += 1;
-        // To do: Find gaps in the ranges.
-
-        // These conversions are fast!
-        let start_i = usize::from(range.start());
-        let end_i = usize::from(range.end());
-        
-        if true {
-            if n_tokens &lt; 20 {
-                println!("{start_i:&gt;3}..{end_i:3} token: {token:?}");
-            }
-        }
-    }
-
-    // Print time.
-    let duration = t1.elapsed();
-    println_f!("{short_file_name}: {n_tokens} tokens in {duration:?}\n");
+    tbo::entry();
 }
 //@-leo
@language python
</t>
<t tx="ekr.20240928162805.7"></t>
<t tx="ekr.20240928162805.8">@ignore
@nosearch
@language patch
--- HEAD
+++ uncommitted
@@ -1,52 +1,11 @@
 @language rust
-// test_lexer.main.rs
-
-// From https://docs.rs/rustpython-parser/0.3.1/rustpython_parser/lexer/index.html
-
-// Must be first.
-// #![allow(unused_imports)]
-#![allow(unused_variables)]
-
-extern crate rustpython_parser;
-use rustpython_parser::{lexer::lex, Mode};
-use std::fs;
-use std::time::Instant; // Tok, StringKind
+// main.rs
 
 #[macro_use]
 extern crate fstrings;
 
+mod tbo;
+
 fn main() {
-    println!("");
-    let t1 = Instant::now();
-    // let source = "x    =      'RustPython'";
-    let file_path = "C:\\Repos\\leo-editor\\leo\\core\\leoApp.py";
-    let short_file_name = "leoApp.py";
-    let contents = fs::read_to_string(file_path).expect("Can not read file");
-
-    // let tokens = lex(contents, Mode::Module)
-    let tokens = lex(&amp;contents, Mode::Module)
-        .map(|tok| tok.expect("Failed to lex"))
-        .collect::&lt;Vec&lt;_&gt;&gt;();
-
-    // :? is debugging format.
-    let mut n_tokens: usize = 0;
-    for (token, range) in tokens {
-        // Range is a TextRange.
-        n_tokens += 1;
-        // To do: Find gaps in the ranges.
-
-        // These conversions are fast!
-        let start_i = usize::from(range.start());
-        let end_i = usize::from(range.end());
-        
-        if true {
-            if n_tokens &lt; 20 {
-                println!("{start_i:&gt;3}..{end_i:3} token: {token:?}");
-            }
-        }
-    }
-
-    // Print time.
-    let duration = t1.elapsed();
-    println_f!("{short_file_name}: {n_tokens} tokens in {duration:?}\n");
+    tbo::entry();
 }
@language python
</t>
<t tx="ekr.20240928162805.9">@language rust
// test_lexer.main.rs

// From https://docs.rs/rustpython-parser/0.3.1/rustpython_parser/lexer/index.html

// Must be first.
// #![allow(unused_imports)]
#![allow(unused_variables)]

extern crate rustpython_parser;
use rustpython_parser::{lexer::lex, Mode};
use std::fs;
use std::time::Instant; // Tok, StringKind

#[macro_use]
extern crate fstrings;

fn main() {
    println!("");
    let t1 = Instant::now();
    // let source = "x    =      'RustPython'";
    let file_path = "C:\\Repos\\leo-editor\\leo\\core\\leoApp.py";
    let short_file_name = "leoApp.py";
    let contents = fs::read_to_string(file_path).expect("Can not read file");

    // let tokens = lex(contents, Mode::Module)
    let tokens = lex(&amp;contents, Mode::Module)
        .map(|tok| tok.expect("Failed to lex"))
        .collect::&lt;Vec&lt;_&gt;&gt;();

    // :? is debugging format.
    let mut n_tokens: usize = 0;
    for (token, range) in tokens {
        // Range is a TextRange.
        n_tokens += 1;
        // To do: Find gaps in the ranges.

        // These conversions are fast!
        let start_i = usize::from(range.start());
        let end_i = usize::from(range.end());
        
        if true {
            if n_tokens &lt; 20 {
                println!("{start_i:&gt;3}..{end_i:3} token: {token:?}");
            }
        }
    }

    // Print time.
    let duration = t1.elapsed();
    println_f!("{short_file_name}: {n_tokens} tokens in {duration:?}\n");
}
</t>
</tnodes>
</leo_file>
